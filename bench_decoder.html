<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="QRAM Bench Decoder">
  <meta name="theme-color" content="#1a1a2e">
  <title>QRAM Bench Decoder</title>
  <link rel="manifest" href="manifest.json">

  <script src="./libs/qram.min.js"></script>
  <script src="./libs/jsQR.js"></script>
  <script src="https://unpkg.com/@zxing/browser@0.1.5/umd/zxing-browser.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e; color: #eee; min-height: 100vh; padding: 14px;
    }
    .container { max-width: 540px; margin: 0 auto; }

    h1 { text-align: center; margin-bottom: 12px; font-size: 1.25rem; color: #00d4ff; }
    h3 { font-size: 0.8rem; color: #888; text-transform: uppercase; letter-spacing: .05em; margin-bottom: 6px; }

    .section { background: #16213e; border-radius: 10px; padding: 12px; margin-bottom: 10px; }

    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
    .row:last-child { margin-bottom: 0; }

    select, input[type="text"], input[type="number"], textarea {
      border-radius: 8px; border: 1px solid #333;
      background: #0d1117; color: #eee; padding: 8px 10px;
      font-size: 0.88rem;
    }
    input[type="text"], input[type="number"] { flex: 1; min-width: 80px; }
    input[type="number"] { max-width: 80px; }
    textarea {
      width: 100%; font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;
      font-size: 10px; color: #0f0; resize: vertical; box-sizing: border-box;
    }

    button {
      border-radius: 10px; border: none; cursor: pointer;
      padding: 10px 14px; font-size: 0.88rem; font-weight: 700;
    }
    .btn-primary   { background: #00ff88; color: #000; }
    .btn-secondary { background: #16213e; color: #eee; border: 1px solid #333; }
    .btn-danger    { background: #ff4b4b; color: #fff; }
    .btn-copy      { background: #00d4ff; color: #000; width: 100%; margin-top: 8px; }
    .btn-export    { background: #ffd700; color: #000; width: 100%; margin-top: 8px; }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    #video-container {
      position: relative; width: 100%; background: #000;
      border-radius: 12px; overflow: hidden; margin: 8px 0; aspect-ratio: 1;
    }
    #video { width: 100%; height: 100%; object-fit: contain; background: #000; }
    #overlay {
      position: absolute; inset: 0; display: flex;
      align-items: center; justify-content: center; pointer-events: none;
    }
    #scan-region {
      width: 85%; height: 85%; border: 2px solid #00d4ff; border-radius: 10px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.45);
    }
    #scan-indicator {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(0,255,136,0.9); color: #000; padding: 4px 12px;
      border-radius: 20px; font-size: .75rem; font-weight: 700;
      opacity: 0; transition: opacity .1s;
    }
    #scan-indicator.flash { opacity: 1; }

    #error-msg {
      background: #ff4444; color: #fff; padding: 10px 14px;
      border-radius: 8px; margin-bottom: 10px; display: none; font-size: 0.88rem;
    }
    #error-msg.show { display: block; }

    /* Stats grid */
    .stats-grid {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 8px;
    }
    .stat-box { background: #0d1117; border-radius: 8px; padding: 8px; text-align: center; }
    .stat-value { font-size: 1.1rem; font-weight: 800; color: #00d4ff; }
    .stat-label { font-size: .65rem; color: #666; margin-top: 2px; }
    .stat-value.green  { color: #00ff88; }
    .stat-value.yellow { color: #ffd700; }
    .stat-value.red    { color: #ff6b6b; }

    #run-id-box { font-family: ui-monospace, monospace; font-size: .8rem; color: #00d4ff; }

    /* Progress bar */
    #progress-bar { width: 100%; height: 8px; background: #0d1117; border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
    #progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg,#00d4ff,#00ff88); transition: width .2s; }

    /* Block timeline */
    #block-timeline {
      font-family: ui-monospace, monospace; font-size: .75rem; color: #0f0;
      max-height: 100px; overflow-y: auto; background: #0d1117;
      border-radius: 6px; padding: 6px 8px; line-height: 1.5;
    }
    #block-timeline:empty::before { content: 'No blocks decoded yet'; color: #555; }

    /* Hash result badge */
    .hash-result {
      padding: 6px 12px; border-radius: 6px; font-size: .82rem;
      font-weight: 700; text-align: center; margin-bottom: 8px;
    }
    .hash-ok      { background: #0a2a0a; color: #00ff88; border: 1px solid #00ff88; }
    .hash-fail    { background: #2a0a0a; color: #ff6b6b; border: 1px solid #ff6b6b; }
    .hash-unknown { background: #16213e; color: #888;    border: 1px solid #333;    }

    /* Result JSON */
    #result-json {
      width: 100%; height: 220px; background: #0d1117; border: 1px solid #333;
      border-radius: 8px; color: #0f0;
      font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;
      font-size: 10px; padding: 8px; resize: vertical;
    }

    #result-section { display: none; }
    #result-section.show { display: block; }

    /* Batch status */
    #batch-progress {
      font-family: ui-monospace, monospace; font-size: .82rem; color: #ffd700;
      min-height: 18px; margin: 6px 0; text-align: center;
    }
    .batch-section { background: #1a2a1a; border: 1px solid #2a4a2a; }

    /* Encoder config textarea */
    #encoder-config-input {
      height: 80px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>QRAM Bench Decoder</h1>

    <div id="error-msg"></div>

    <!-- Controls -->
    <div class="section">
      <div class="row">
        <button id="camera-btn"    class="btn-primary">Camera</button>
        <button id="video-file-btn" class="btn-secondary">Video File</button>
        <button id="reset-btn"     class="btn-danger">Reset</button>
        <input id="video-file-input" type="file" accept="video/*" style="display:none">
      </div>
      <div class="row">
        <label style="color:#bbb;font-size:.85rem;font-weight:700;">Decoder</label>
        <select id="decoder-lib-select">
          <option value="zxing" selected>ZXing</option>
          <option value="jsqr">jsQR (QR only)</option>
        </select>
        <label style="color:#bbb;font-size:.85rem;font-weight:700;">Format</label>
        <select id="format-select">
          <option value="AUTO" selected>Auto</option>
          <option value="AZTEC">Aztec</option>
          <option value="DATA_MATRIX">Data Matrix</option>
          <option value="QR_CODE">QR Code</option>
          <option value="PDF_417">PDF417</option>
        </select>
        <label style="color:#bbb;font-size:.85rem;font-weight:700;">Scan</label>
        <select id="scan-interval">
          <option value="250">250ms</option>
          <option value="120">120ms</option>
          <option value="80" selected>80ms</option>
          <option value="50">50ms</option>
        </select>
      </div>
      <div class="row">
        <label style="color:#bbb;font-size:.85rem;font-weight:700;">Encoding</label>
        <select id="packet-encoding-select">
          <option value="base64url" selected>base64url</option>
          <option value="binary">binary</option>
        </select>
        <label style="color:#bbb;font-size:.85rem;font-weight:700;">Timeout</label>
        <input type="number" id="run-timeout" value="120" min="10" max="3600" style="max-width:70px">
        <span style="color:#888;font-size:.8rem;">sec</span>
        <label style="color:#bbb;font-size:.85rem;font-weight:700;">Idle timeout</label>
        <input type="number" id="idle-timeout" value="90" min="10" max="600" style="max-width:70px">
        <span style="color:#888;font-size:.8rem;">sec</span>
      </div>
    </div>

    <!-- Expected hash + env -->
    <div class="section">
      <h3>Run Config</h3>
      <div class="row">
        <label style="color:#bbb;font-size:.82rem;white-space:nowrap;">Expected hash</label>
        <input type="text" id="expected-hash" placeholder="Paste payloadHash from encoder config JSON">
      </div>
      <div class="row">
        <label style="color:#bbb;font-size:.82rem;white-space:nowrap;">Distance</label>
        <input type="text" id="env-distance" placeholder="e.g. 60cm" style="max-width:90px">
        <label style="color:#bbb;font-size:.82rem;white-space:nowrap;">Brightness</label>
        <input type="text" id="env-brightness" placeholder="e.g. 80%" style="max-width:80px">
      </div>
      <div class="row">
        <label style="color:#bbb;font-size:.82rem;white-space:nowrap;">Notes</label>
        <input type="text" id="env-notes" placeholder="lighting, conditions, device state…">
      </div>
    </div>

    <!-- Encoder Config Echo -->
    <div class="section">
      <h3>Encoder Config (paste for result echo)</h3>
      <textarea id="encoder-config-input" placeholder="Paste the encoder config JSON here (or JSON array for batch). Key fields will be echoed into results."></textarea>
    </div>

    <!-- Video -->
    <div id="video-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="jsqr-canvas" style="display:none"></canvas>
      <div id="overlay"><div id="scan-region"></div></div>
      <div id="scan-indicator">Packet</div>
    </div>

    <!-- Progress bar -->
    <div id="progress-bar"><div id="progress-fill"></div></div>

    <!-- Live stats -->
    <div class="section">
      <div id="run-id-box" style="margin-bottom:8px;">Run: —</div>
      <div class="stats-grid">
        <div class="stat-box">
          <div class="stat-value" id="st-scan-attempts">0</div>
          <div class="stat-label">Scan attempts</div>
        </div>
        <div class="stat-box">
          <div class="stat-value green" id="st-scan-successes">0</div>
          <div class="stat-label">Scan successes</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="st-success-rate">—</div>
          <div class="stat-label">Success rate</div>
        </div>
        <div class="stat-box">
          <div class="stat-value yellow" id="st-dedup-drops">0</div>
          <div class="stat-label">Dedup drops</div>
        </div>
        <div class="stat-box">
          <div class="stat-value green" id="st-unique-pkts">0</div>
          <div class="stat-label">Unique packets</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="st-pkts-per-sec">—</div>
          <div class="stat-label">Pkts/sec</div>
        </div>
        <div class="stat-box">
          <div class="stat-value green" id="st-blocks">0</div>
          <div class="stat-label">Blocks decoded</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="st-blocks-total">?</div>
          <div class="stat-label">Total blocks</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="st-elapsed">0s</div>
          <div class="stat-label">Elapsed</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="st-enqueue-accepts">0</div>
          <div class="stat-label">Enq accepts</div>
        </div>
        <div class="stat-box">
          <div class="stat-value red" id="st-enqueue-rejects">0</div>
          <div class="stat-label">Enq rejects</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="st-scans-per-sec">—</div>
          <div class="stat-label">Scans/sec</div>
        </div>
      </div>
    </div>

    <!-- Block timeline -->
    <div class="section">
      <h3>Block Decode Timeline</h3>
      <div id="block-timeline"></div>
    </div>

    <!-- Batch progress -->
    <div class="section batch-section">
      <h3>Batch Progress</h3>
      <div id="batch-progress">No batch active</div>
      <button id="export-all-btn" class="btn-export" disabled>Export All Results (JSON)</button>
    </div>

    <!-- Result (shown on complete or manual export) -->
    <div id="result-section">
      <div class="section">
        <h3>Result</h3>
        <div id="hash-result" class="hash-result hash-unknown">—</div>
        <textarea id="result-json" readonly></textarea>
        <button id="copy-result" class="btn-copy">Copy Result JSON</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // === Elements ===
  const video          = document.getElementById('video');
  const jsqrCanvas     = document.getElementById('jsqr-canvas');
  const errorMsg       = document.getElementById('error-msg');
  const scanIndicator  = document.getElementById('scan-indicator');
  const progressFill   = document.getElementById('progress-fill');
  const runIdBox       = document.getElementById('run-id-box');

  const stScanAttempts  = document.getElementById('st-scan-attempts');
  const stScanSuccesses = document.getElementById('st-scan-successes');
  const stSuccessRate   = document.getElementById('st-success-rate');
  const stDedupDrops    = document.getElementById('st-dedup-drops');
  const stUniquePkts    = document.getElementById('st-unique-pkts');
  const stPktsPerSec    = document.getElementById('st-pkts-per-sec');
  const stBlocks        = document.getElementById('st-blocks');
  const stBlocksTotal   = document.getElementById('st-blocks-total');
  const stElapsed       = document.getElementById('st-elapsed');
  const stEnqueueAccepts = document.getElementById('st-enqueue-accepts');
  const stEnqueueRejects = document.getElementById('st-enqueue-rejects');
  const stScansPerSec    = document.getElementById('st-scans-per-sec');

  const blockTimelineEl  = document.getElementById('block-timeline');
  const resultSection    = document.getElementById('result-section');
  const hashResultEl     = document.getElementById('hash-result');
  const resultJsonEl     = document.getElementById('result-json');
  const copyResultBtn    = document.getElementById('copy-result');

  const cameraBtn       = document.getElementById('camera-btn');
  const videoFileBtn    = document.getElementById('video-file-btn');
  const videoFileInput  = document.getElementById('video-file-input');
  const resetBtn        = document.getElementById('reset-btn');
  const formatSelect    = document.getElementById('format-select');
  const scanIntervalSel = document.getElementById('scan-interval');
  const decoderLibSelect = document.getElementById('decoder-lib-select');
  const packetEncSelect  = document.getElementById('packet-encoding-select');
  const runTimeoutEl     = document.getElementById('run-timeout');
  const idleTimeoutEl    = document.getElementById('idle-timeout');

  const expectedHashEl  = document.getElementById('expected-hash');
  const envDistanceEl   = document.getElementById('env-distance');
  const envBrightnessEl = document.getElementById('env-brightness');
  const envNotesEl      = document.getElementById('env-notes');

  const encoderConfigInput = document.getElementById('encoder-config-input');
  const batchProgressEl    = document.getElementById('batch-progress');
  const exportAllBtn       = document.getElementById('export-all-btn');

  // === State ===
  let scanning       = false;
  let decoder        = null;
  let detectedRunId  = null;
  let seenSeqNums    = new Set();
  let runStartTime   = null;

  // Counters
  let scanAttempts    = 0;
  let scanSuccesses   = 0;
  let dedupDrops      = 0;
  let uniquePackets   = 0;
  let enqueueAttempts = 0;
  let enqueueAccepts  = 0;
  let enqueueRejects  = 0;

  // Timing
  let firstPacketTime = null;
  let firstBlockTime  = null;

  // Block state
  let lastReceivedBlocks = 0;
  let lastTotalBlocks    = 0;

  // Timelines
  let blockTimeline  = [];
  let packetTimeline = [];

  // ZXing
  let zxingControls = null;
  let zxingReader   = null;
  let cameraStream  = null;

  // jsQR
  let jsqrTimer = null;

  // Timeouts
  let uiTimer = null;
  let runTimeoutTimer  = null;
  let idleTimeoutTimer = null;
  let lastPacketReceivedTime = null;

  // Batch
  let allBatchResults = [];
  let batchRunCount   = 0;
  let batchSuccessCount = 0;
  let batchFailCount    = 0;
  let previousRunId     = null;

  // === Helpers ===
  function showError(msg) {
    errorMsg.textContent = msg;
    errorMsg.classList.add('show');
  }
  function hideError() { errorMsg.classList.remove('show'); }

  function flashIndicator() {
    scanIndicator.classList.add('flash');
    setTimeout(() => scanIndicator.classList.remove('flash'), 120);
  }

  function fmtMs(ms) {
    if (ms === null || ms === undefined) return '—';
    if (ms < 1000) return ms.toFixed(0) + 'ms';
    return (ms / 1000).toFixed(2) + 's';
  }

  function base64UrlToBytes(s) {
    const t = (s || '').trim().replace(/-/g, '+').replace(/_/g, '/');
    const padded = t + '==='.slice((t.length + 3) % 4);
    const bin = atob(padded);
    const out = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i) & 0xff;
    return out;
  }

  async function sha256hex(data) {
    const buf = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(buf), b => b.toString(16).padStart(2, '0')).join('');
  }

  // Parse a bench-encoded barcode.
  // New header (8 bytes): [runId: 4 bytes] [seqNum: 4 bytes BE] [qramData: N bytes]
  function parsePacket(textOrBytes) {
    try {
      const encoding = packetEncSelect.value;
      let raw;

      if (encoding === 'binary') {
        // textOrBytes is already a Uint8Array from getRawBytes
        if (textOrBytes instanceof Uint8Array) {
          raw = textOrBytes;
        } else {
          return null;
        }
      } else {
        // base64url text
        raw = base64UrlToBytes(textOrBytes);
      }

      if (raw.length < 9) return null; // need >= 8 header + 1 qram byte
      const runIdHex = Array.from(raw.slice(0, 4), b => b.toString(16).padStart(2, '0')).join('');
      const seqNum   = (raw[4] << 24 | raw[5] << 16 | raw[6] << 8 | raw[7]) >>> 0;
      const qramData = raw.slice(8);
      return { runIdHex, seqNum, qramData };
    } catch (_) {
      return null;
    }
  }

  // Get encoder config for current run from pasted JSON
  function getEncoderConfigForRun(runId) {
    const text = encoderConfigInput.value.trim();
    if (!text) return null;
    try {
      const parsed = JSON.parse(text);
      if (Array.isArray(parsed)) {
        return parsed.find(c => c.runId === runId) || null;
      }
      if (parsed.runId === runId) return parsed;
      // If single config with no runId match, return it anyway (user may have pasted a single config)
      return parsed;
    } catch (_) {
      return null;
    }
  }

  function getDecoderLibInfo() {
    const lib = decoderLibSelect.value;
    if (lib === 'zxing') {
      if (window.ZXingBrowser) {
        // Try to get version
        const ver = ZXingBrowser.version || ZXingBrowser.VERSION || '0.1.5';
        return { name: 'ZXing', version: 'ZXing @' + ver };
      }
      return { name: 'ZXing', version: 'ZXing @0.1.5' };
    }
    if (lib === 'jsqr') {
      return { name: 'jsQR', version: 'jsQR (bundled)' };
    }
    return { name: lib, version: lib };
  }

  // === UI Updates ===
  function updateUI() {
    stScanAttempts.textContent  = scanAttempts;
    stScanSuccesses.textContent = scanSuccesses;
    stSuccessRate.textContent   = scanAttempts > 0
      ? (scanSuccesses / scanAttempts * 100).toFixed(0) + '%' : '—';
    stDedupDrops.textContent    = dedupDrops;
    stUniquePkts.textContent    = uniquePackets;
    stBlocks.textContent        = lastReceivedBlocks;
    stBlocksTotal.textContent   = lastTotalBlocks > 0 ? lastTotalBlocks : '?';
    stEnqueueAccepts.textContent = enqueueAccepts;
    stEnqueueRejects.textContent = enqueueRejects;

    const elapsed = runStartTime ? (Date.now() - runStartTime) / 1000 : 0;
    stElapsed.textContent = elapsed > 0 ? elapsed.toFixed(1) + 's' : '0s';

    stPktsPerSec.textContent = (elapsed > 0.5 && uniquePackets > 0)
      ? (uniquePackets / elapsed).toFixed(1) + '/s' : '—';

    // Actual scans per second
    stScansPerSec.textContent = (elapsed > 0.5 && scanAttempts > 0)
      ? (scanAttempts / elapsed).toFixed(1) + '/s' : '—';

    const pct = lastTotalBlocks > 0
      ? Math.min(100, (lastReceivedBlocks / lastTotalBlocks) * 100) : 0;
    progressFill.style.width = pct + '%';

    if (detectedRunId) runIdBox.textContent = 'Run: ' + detectedRunId;
  }

  function startUITimer() {
    if (uiTimer) return;
    uiTimer = setInterval(updateUI, 500);
  }
  function stopUITimer() {
    if (uiTimer) { clearInterval(uiTimer); uiTimer = null; }
  }

  // === Timeout management ===
  function startRunTimeout() {
    clearRunTimeout();
    const sec = Math.max(10, parseInt(runTimeoutEl.value, 10) || 120);
    runTimeoutTimer = setTimeout(() => {
      onRunTimeout();
    }, sec * 1000);
  }

  function clearRunTimeout() {
    if (runTimeoutTimer) { clearTimeout(runTimeoutTimer); runTimeoutTimer = null; }
  }

  function startIdleTimeout() {
    clearIdleTimeout();
    const sec = Math.max(10, parseInt(idleTimeoutEl.value, 10) || 90);
    idleTimeoutTimer = setTimeout(() => {
      onIdleTimeout();
    }, sec * 1000);
  }

  function clearIdleTimeout() {
    if (idleTimeoutTimer) { clearTimeout(idleTimeoutTimer); idleTimeoutTimer = null; }
  }

  function resetIdleTimeout() {
    lastPacketReceivedTime = Date.now();
    startIdleTimeout();
  }

  async function onRunTimeout() {
    if (!scanning) return;
    scanning = false;
    stopUITimer();
    clearRunTimeout();
    clearIdleTimeout();
    await exportPartialResult('timeout');
    // In batch mode, wait for next run ID; in single mode, stop
    if (allBatchResults.length > 0 || batchRunCount > 0) {
      waitForNextRun();
    } else {
      stopAllInputs();
    }
  }

  async function onIdleTimeout() {
    if (!scanning || !detectedRunId) return;
    scanning = false;
    stopUITimer();
    clearRunTimeout();
    clearIdleTimeout();
    await exportPartialResult('idle_timeout');
    waitForNextRun();
  }

  function waitForNextRun() {
    // Keep scanning active but reset state for next run
    scanning = true;
    previousRunId = detectedRunId;
    resetRunState();
    resetRunUI();
    updateBatchProgress();
    startUITimer();
  }

  // === ZXing ===
  function stopZXing() {
    try { if (zxingControls?.stop) zxingControls.stop(); } catch (_) {}
    zxingControls = null;
    try { if (zxingReader?.reset) zxingReader.reset(); } catch (_) {}
    zxingReader = null;
  }

  // === jsQR ===
  function stopJsQR() {
    if (jsqrTimer) { clearInterval(jsqrTimer); jsqrTimer = null; }
  }

  function stopCamera() {
    if (cameraStream) { cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null; }
  }

  function stopAllInputs() {
    stopZXing();
    stopJsQR();
    stopCamera();
    clearRunTimeout();
    clearIdleTimeout();
    try {
      if (video.src && video.src.startsWith('blob:')) URL.revokeObjectURL(video.src);
    } catch (_) {}
    video.srcObject = null;
    video.src = '';
  }

  function buildZXingReader() {
    if (!window.ZXingBrowser) throw new Error('ZXingBrowser not loaded');
    const hints = new Map();
    if (ZXingBrowser.DecodeHintType && ZXingBrowser.BarcodeFormat) {
      const fmt = formatSelect.value;
      const map = {
        AZTEC:       ZXingBrowser.BarcodeFormat.AZTEC,
        DATA_MATRIX: ZXingBrowser.BarcodeFormat.DATA_MATRIX,
        QR_CODE:     ZXingBrowser.BarcodeFormat.QR_CODE,
        PDF_417:     ZXingBrowser.BarcodeFormat.PDF_417,
      };
      if (fmt !== 'AUTO') hints.set(ZXingBrowser.DecodeHintType.POSSIBLE_FORMATS, [map[fmt]]);
      hints.set(ZXingBrowser.DecodeHintType.TRY_HARDER, true);
    }
    const interval = parseInt(scanIntervalSel.value, 10) || 80;
    zxingReader = new ZXingBrowser.BrowserMultiFormatReader(hints, interval);
  }

  // === Scan callback (shared by ZXing and jsQR) ===
  async function onScanResult(rawTextOrBytes) {
    if (!scanning) return;

    const parsed = parsePacket(rawTextOrBytes);
    if (!parsed) return; // not a bench-format packet

    scanSuccesses++;

    const { runIdHex, seqNum, qramData } = parsed;

    // Run ID change detection (batch mode)
    if (detectedRunId !== null && detectedRunId !== runIdHex) {
      // The encoder moved to a new run
      // Export current run results first
      if (uniquePackets > 0) {
        const prevScanning = scanning;
        scanning = false;
        stopUITimer();
        clearRunTimeout();
        clearIdleTimeout();
        await exportPartialResult('run_id_changed');
        scanning = prevScanning;
      }
      // Reset for new run
      previousRunId = detectedRunId;
      resetRunState();
      resetRunUI();
      updateBatchProgress();
    }

    // Latch onto the first run ID we see (or new run after reset)
    if (detectedRunId === null) {
      detectedRunId = runIdHex;
      runStartTime  = Date.now();
      lastPacketReceivedTime = Date.now();
      startUITimer();
      startRunTimeout();
      startIdleTimeout();
    }

    if (detectedRunId !== runIdHex) return; // shouldn't happen but safety check

    // Dedup by sequence number
    if (seenSeqNums.has(seqNum)) {
      dedupDrops++;
      return;
    }
    seenSeqNums.add(seqNum);

    const now     = Date.now();
    const elapsed = now - runStartTime;

    if (!firstPacketTime) firstPacketTime = now;

    uniquePackets++;
    resetIdleTimeout();

    if (packetTimeline.length < 1000) {
      packetTimeline.push({ seq: seqNum, elapsedMs: elapsed });
    }

    flashIndicator();

    // Enqueue into qram decoder
    enqueueAttempts++;
    try {
      const progress = await decoder.enqueue(qramData);
      enqueueAccepts++;

      if (progress) {
        const newBlocks = progress.receivedBlocks;

        if (newBlocks > lastReceivedBlocks) {
          const tNow     = Date.now();
          const tElapsed = tNow - runStartTime;

          for (let b = lastReceivedBlocks; b < newBlocks; b++) {
            blockTimeline.push({
              blockIdx:        b,
              elapsedMs:       tElapsed,
              uniquePacketCount: uniquePackets,
            });
            const entry = document.createElement('div');
            entry.textContent =
              `Block ${b} at ${fmtMs(tElapsed)} | ${uniquePackets} unique pkts`;
            blockTimelineEl.appendChild(entry);
            blockTimelineEl.scrollTop = blockTimelineEl.scrollHeight;
          }

          if (lastReceivedBlocks === 0 && newBlocks > 0) firstBlockTime = Date.now();
        }

        lastReceivedBlocks = progress.receivedBlocks;
        lastTotalBlocks    = progress.totalBlocks;
      }
    } catch (_) {
      enqueueRejects++;
    }
  }

  // === ZXing callback ===
  async function onZXingCallback(result, err) {
    if (!scanning) return;
    scanAttempts++;

    if (!result) return; // scan miss

    const encoding = packetEncSelect.value;
    if (encoding === 'binary') {
      // Try getRawBytes first for binary mode
      try {
        const rawBytes = result.getRawBytes();
        if (rawBytes && rawBytes.length > 0) {
          await onScanResult(rawBytes);
          return;
        }
      } catch (_) {}
      // Fallback to text
    }

    const rawText = result.getText();
    if (!rawText) return;
    await onScanResult(rawText);
  }

  // === jsQR scanning loop ===
  function startJsQRLoop() {
    if (!window.jsQR) throw new Error('jsQR library not loaded');
    const interval = parseInt(scanIntervalSel.value, 10) || 80;
    const ctx = jsqrCanvas.getContext('2d', { willReadFrequently: true });

    jsqrTimer = setInterval(() => {
      if (!scanning) return;
      if (video.readyState < 2) return; // HAVE_CURRENT_DATA

      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return;

      jsqrCanvas.width  = w;
      jsqrCanvas.height = h;
      ctx.drawImage(video, 0, 0, w, h);

      scanAttempts++;

      const imageData = ctx.getImageData(0, 0, w, h);
      const code = jsQR(imageData.data, w, h, { inversionAttempts: 'dontInvert' });

      if (code && code.data) {
        onScanResult(code.data);
      }
    }, interval);
  }

  // === Completion ===
  async function onComplete(result) {
    scanning = false;
    stopUITimer();
    clearRunTimeout();
    clearIdleTimeout();
    updateUI();

    const decodeCompleteTime = Date.now();
    const data = result.data;

    const payloadHashSha256 = await sha256hex(data);
    const expectedHash      = expectedHashEl.value.trim().toLowerCase();
    const hashVerified       = expectedHash
      ? payloadHashSha256 === expectedHash
      : null;

    const totalDecodeTimeMs     = runStartTime ? decodeCompleteTime - runStartTime : null;
    const timeToFirstPacketMs   = (firstPacketTime && runStartTime)
      ? firstPacketTime - runStartTime : null;
    const timeToFirstBlockMs    = (firstBlockTime && runStartTime)
      ? firstBlockTime - runStartTime : null;
    const elapsed               = totalDecodeTimeMs ? totalDecodeTimeMs / 1000 : 0;
    const packetsPerSec         = (elapsed > 0 && uniquePackets > 0)
      ? Math.round(uniquePackets / elapsed * 10) / 10 : null;
    const actualScansPerSec     = (elapsed > 0 && scanAttempts > 0)
      ? Math.round(scanAttempts / elapsed * 10) / 10 : null;
    const scanSuccessRate       = scanAttempts > 0
      ? Math.round(scanSuccesses / scanAttempts * 1000) / 1000 : null;
    const overheadRatio         = (lastTotalBlocks > 0 && uniquePackets > 0)
      ? Math.round(uniquePackets / lastTotalBlocks * 100) / 100 : null;

    const resultObj = buildResultJson({
      success: true,
      failureReason: null,
      decodeCompleteTime,
      totalDecodeTimeMs,
      timeToFirstPacketMs,
      timeToFirstBlockMs,
      payloadSize: data.length,
      payloadHashSha256,
      expectedHash: expectedHash || null,
      hashVerified,
      packetsPerSec,
      actualScansPerSec,
      scanSuccessRate,
      overheadRatio,
    });

    // Add to batch results
    allBatchResults.push(resultObj);
    batchRunCount++;
    batchSuccessCount++;
    updateBatchProgress();
    exportAllBtn.disabled = false;

    showResult(resultObj, hashVerified);

    // In batch-aware mode, wait for next run
    if (cameraStream || video.src) {
      waitForNextRun();
    }
  }

  // === Partial / failed run export ===
  async function exportPartialResult(reason) {
    const now = Date.now();
    const totalMs = runStartTime ? now - runStartTime : null;
    const elapsed = totalMs ? totalMs / 1000 : 0;
    const packetsPerSec = (elapsed > 0 && uniquePackets > 0)
      ? Math.round(uniquePackets / elapsed * 10) / 10 : null;
    const actualScansPerSec = (elapsed > 0 && scanAttempts > 0)
      ? Math.round(scanAttempts / elapsed * 10) / 10 : null;
    const scanSuccessRate = scanAttempts > 0
      ? Math.round(scanSuccesses / scanAttempts * 1000) / 1000 : null;
    const overheadRatio = (lastTotalBlocks > 0 && uniquePackets > 0)
      ? Math.round(uniquePackets / lastTotalBlocks * 100) / 100 : null;

    const resultObj = buildResultJson({
      success: false,
      failureReason: reason,
      decodeCompleteTime: null,
      totalDecodeTimeMs: totalMs,
      timeToFirstPacketMs: (firstPacketTime && runStartTime) ? firstPacketTime - runStartTime : null,
      timeToFirstBlockMs:  (firstBlockTime  && runStartTime) ? firstBlockTime  - runStartTime : null,
      payloadSize: null,
      payloadHashSha256: null,
      expectedHash: expectedHashEl.value.trim() || null,
      hashVerified: null,
      packetsPerSec,
      actualScansPerSec,
      scanSuccessRate,
      overheadRatio,
    });

    // Add to batch results
    allBatchResults.push(resultObj);
    batchRunCount++;
    batchFailCount++;
    updateBatchProgress();
    exportAllBtn.disabled = false;

    showResult(resultObj, null);
  }

  function buildResultJson(extras) {
    const libInfo = getDecoderLibInfo();
    const encoderConfig = getEncoderConfigForRun(detectedRunId);

    const result = {
      runId:              detectedRunId,
      timestamp:          new Date().toISOString(),
      decoderLib:         libInfo.version,
      barcodeFormat:      formatSelect.value,
      packetEncoding:     packetEncSelect.value,
      scanIntervalMs:     parseInt(scanIntervalSel.value, 10),
      success:            extras.success,
      failureReason:      extras.failureReason,

      timeToFirstPacketMs:   extras.timeToFirstPacketMs,
      timeToFirstBlockMs:    extras.timeToFirstBlockMs,
      totalDecodeTimeMs:     extras.totalDecodeTimeMs,

      scanAttempts,
      scanSuccesses,
      scanSuccessRate:    extras.scanSuccessRate,
      actualScansPerSec:  extras.actualScansPerSec,
      dedupDrops,
      uniquePackets,

      enqueueAttempts,
      enqueueAccepts,
      enqueueRejects,

      blocksDecoded:      lastReceivedBlocks,
      blocksTotal:        lastTotalBlocks,
      overheadRatio:      extras.overheadRatio,
      packetsPerSec:      extras.packetsPerSec,

      payloadSize:        extras.payloadSize,
      payloadHashSha256:  extras.payloadHashSha256,
      expectedHash:       extras.expectedHash,
      hashVerified:       extras.hashVerified,

      blockTimeline,
      packetTimeline: packetTimeline.slice(0, 500),

      env: {
        distance:   envDistanceEl.value.trim()   || null,
        brightness: envBrightnessEl.value.trim() || null,
        notes:      envNotesEl.value.trim()      || null,
      },

      // Library versions
      qramVersion: (window.qram && qram.version) ? qram.version : (window.qram ? 'loaded (version unknown)' : 'not loaded'),
    };

    // Echo encoder config fields if available
    if (encoderConfig) {
      result.encoderConfig = {
        barcodeType:    encoderConfig.barcodeType    || null,
        blockSize:      encoderConfig.blockSize      || null,
        fps:            encoderConfig.fps            || null,
        payloadSize:    encoderConfig.payloadSize    || null,
        packetEncoding: encoderConfig.packetEncoding || null,
        encoderLib:     encoderConfig.encoderLib     || null,
        encoderLibVersion: encoderConfig.encoderLibVersion || null,
        ecLevel:        encoderConfig.ecLevel        || null,
        scale:          encoderConfig.scale          || null,
        randomSeed:     encoderConfig.randomSeed     || null,
      };
    }

    return result;
  }

  function showResult(obj, hashVerified) {
    const jsonStr = JSON.stringify(obj, null, 2);
    resultJsonEl.value = jsonStr;
    resultSection.classList.add('show');

    if (hashVerified === true) {
      hashResultEl.textContent  = 'Hash verified — payload intact';
      hashResultEl.className    = 'hash-result hash-ok';
    } else if (hashVerified === false) {
      hashResultEl.textContent  = 'Hash MISMATCH — payload corrupted!';
      hashResultEl.className    = 'hash-result hash-fail';
    } else if (obj.success) {
      hashResultEl.textContent  = 'Hash not verified (paste expectedHash above to verify)';
      hashResultEl.className    = 'hash-result hash-unknown';
    } else {
      hashResultEl.textContent  = 'Run incomplete — ' + (obj.failureReason || 'unknown reason');
      hashResultEl.className    = 'hash-result hash-unknown';
    }

    // Auto-copy to clipboard
    navigator.clipboard.writeText(jsonStr).then(() => {
      copyResultBtn.textContent = 'Auto-copied!';
      setTimeout(() => copyResultBtn.textContent = 'Copy Result JSON', 3000);
    }).catch(() => {});
  }

  function updateBatchProgress() {
    if (batchRunCount === 0 && allBatchResults.length === 0) {
      batchProgressEl.textContent = 'No batch active';
      return;
    }
    batchProgressEl.textContent =
      `Run ${batchRunCount} completed — ${batchSuccessCount} success, ${batchFailCount} failed — ` +
      (scanning ? 'waiting for next run…' : 'idle');
  }

  function resetRunState() {
    decoder        = null;
    detectedRunId  = null;
    seenSeqNums    = new Set();
    runStartTime   = null;
    firstPacketTime = null;
    firstBlockTime  = null;
    scanAttempts   = 0;
    scanSuccesses  = 0;
    dedupDrops     = 0;
    uniquePackets  = 0;
    enqueueAttempts = 0;
    enqueueAccepts  = 0;
    enqueueRejects  = 0;
    lastReceivedBlocks = 0;
    lastTotalBlocks    = 0;
    blockTimeline  = [];
    packetTimeline = [];
    lastPacketReceivedTime = null;

    initDecoder();
  }

  function resetRunUI() {
    runIdBox.textContent       = 'Run: —';
    stScanAttempts.textContent = '0';
    stScanSuccesses.textContent = '0';
    stSuccessRate.textContent  = '—';
    stDedupDrops.textContent   = '0';
    stUniquePkts.textContent   = '0';
    stPktsPerSec.textContent   = '—';
    stBlocks.textContent       = '0';
    stBlocksTotal.textContent  = '?';
    stElapsed.textContent      = '0s';
    stEnqueueAccepts.textContent = '0';
    stEnqueueRejects.textContent = '0';
    stScansPerSec.textContent    = '—';
    progressFill.style.width   = '0%';
    blockTimelineEl.innerHTML  = '';
    resultSection.classList.remove('show');
    resultJsonEl.value         = '';
    hideError();
  }

  function resetAllState() {
    resetRunState();
    allBatchResults = [];
    batchRunCount   = 0;
    batchSuccessCount = 0;
    batchFailCount    = 0;
    previousRunId     = null;
    exportAllBtn.disabled = true;
    updateBatchProgress();
  }

  function initDecoder() {
    decoder = new qram.Decoder();
    decoder.decode()
      .then(onComplete)
      .catch(err => {
        if (err.name !== 'AbortError') showError('Decode error: ' + err.message);
      });
  }

  // === Camera mode ===
  async function startCameraMode() {
    try {
      stopUITimer();
      stopZXing();
      stopJsQR();
      stopCamera();
      clearRunTimeout();
      clearIdleTimeout();
      if (decoder) { try { decoder.cancel?.(); } catch (_) {} }
      resetRunState();
      resetRunUI();

      scanning = true;
      initDecoder();

      const decoderLib = decoderLibSelect.value;

      cameraStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' },
      });
      video.srcObject = cameraStream;
      video.playsInline = true;
      video.muted = true;

      await new Promise((resolve, reject) => {
        if (video.readyState >= 1) resolve();
        else {
          video.addEventListener('loadedmetadata', resolve, { once: true });
          video.addEventListener('error', reject, { once: true });
        }
      });
      await video.play();

      if (decoderLib === 'zxing') {
        buildZXingReader();
        zxingControls = await zxingReader.decodeFromVideoDevice(
          null, video,
          (result, err) => onZXingCallback(result, err)
        );
      } else if (decoderLib === 'jsqr') {
        startJsQRLoop();
      }
    } catch (err) {
      scanning = false;
      if (decoder) { try { decoder.cancel?.(); } catch (_) {} }
      showError('Camera init failed: ' + (err?.message || err));
    }
  }

  // === Video file mode ===
  async function startVideoFileMode(file) {
    try {
      stopUITimer();
      stopZXing();
      stopJsQR();
      stopCamera();
      clearRunTimeout();
      clearIdleTimeout();
      if (decoder) { try { decoder.cancel?.(); } catch (_) {} }
      resetRunState();
      resetRunUI();

      scanning = true;
      initDecoder();

      const decoderLib = decoderLibSelect.value;

      const url = URL.createObjectURL(file);
      video.srcObject = null;
      video.src = url;
      video.loop = true;
      video.muted = true;
      video.playsInline = true;

      await new Promise((resolve, reject) => {
        video.onloadedmetadata = resolve;
        video.onerror = reject;
      });
      await video.play();

      const vc = document.getElementById('video-container');
      if (video.videoWidth && video.videoHeight) {
        vc.style.aspectRatio = `${video.videoWidth} / ${video.videoHeight}`;
      }

      if (decoderLib === 'zxing') {
        buildZXingReader();
        zxingControls = await zxingReader.decodeFromVideoElement(
          video,
          (result, err) => onZXingCallback(result, err)
        );
      } else if (decoderLib === 'jsqr') {
        startJsQRLoop();
      }
    } catch (err) {
      scanning = false;
      if (decoder) { try { decoder.cancel?.(); } catch (_) {} }
      showError('Video scan init failed: ' + (err?.message || err));
    }
  }

  // === Buttons ===
  cameraBtn.addEventListener('click', () => startCameraMode());

  videoFileBtn.addEventListener('click', () => videoFileInput.click());
  videoFileInput.addEventListener('change', async () => {
    const file = videoFileInput.files?.[0];
    if (!file) return;
    await startVideoFileMode(file);
    videoFileInput.value = '';
  });

  resetBtn.addEventListener('click', async () => {
    const wasRunning = scanning && detectedRunId !== null && uniquePackets > 0;

    stopUITimer();
    stopZXing();
    stopJsQR();
    stopCamera();
    clearRunTimeout();
    clearIdleTimeout();
    if (decoder) { try { decoder.cancel?.(); } catch (_) {} }

    if (wasRunning) {
      scanning = false;
      await exportPartialResult('user_reset');
    } else {
      scanning = false;
    }

    resetRunState();
    resetRunUI();
  });

  copyResultBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(resultJsonEl.value);
      copyResultBtn.textContent = 'Copied!';
      setTimeout(() => copyResultBtn.textContent = 'Copy Result JSON', 2500);
    } catch (_) {
      resultJsonEl.select();
      document.execCommand('copy');
    }
  });

  // Export all batch results
  exportAllBtn.addEventListener('click', async () => {
    if (allBatchResults.length === 0) return;
    const jsonStr = JSON.stringify(allBatchResults, null, 2);
    try {
      await navigator.clipboard.writeText(jsonStr);
      exportAllBtn.textContent = 'Copied all results!';
      setTimeout(() => exportAllBtn.textContent = 'Export All Results (JSON)', 3000);
    } catch (_) {
      // Fallback: show in result textarea
      resultJsonEl.value = jsonStr;
      resultSection.classList.add('show');
    }
  });

  formatSelect.addEventListener('change', () => {
    if (scanning) {
      stopUITimer();
      stopZXing();
      stopJsQR();
      stopCamera();
      clearRunTimeout();
      clearIdleTimeout();
      if (decoder) { try { decoder.cancel?.(); } catch (_) {} }
      resetRunState();
      resetRunUI();
    }
  });

  decoderLibSelect.addEventListener('change', () => {
    if (decoderLibSelect.value === 'jsqr') {
      // jsQR only supports QR codes
      formatSelect.value = 'QR_CODE';
    }
    if (scanning) {
      stopUITimer();
      stopZXing();
      stopJsQR();
      stopCamera();
      clearRunTimeout();
      clearIdleTimeout();
      if (decoder) { try { decoder.cancel?.(); } catch (_) {} }
      resetRunState();
      resetRunUI();
    }
  });

  // SW registration for PWA
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').catch(() => {});
  }

  resetRunUI();
  updateBatchProgress();
})();
</script>
</body>
</html>
