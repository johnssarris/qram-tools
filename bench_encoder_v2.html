<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QRAM Bench Encoder</title>
  <script src="./libs/qram.min.js"></script>
  <script src="./libs/qrcode.min.js"></script>
  <style>
    body { font-family: system-ui; background: #1a1a2e; color: #eee; padding: 16px; max-width: 860px; margin: auto; }
    h2 { margin: 0 0 14px 0; color: #00d4ff; font-size: 1.2rem; }
    h3 { margin: 14px 0 8px 0; color: #aaa; font-size: 0.9rem; text-transform: uppercase; letter-spacing: .05em; }

    .section { background: #16213e; border-radius: 10px; padding: 14px; margin-bottom: 12px; }

    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 10px; }
    .row:last-child { margin-bottom: 0; }

    label { color: #c8c8c8; display: flex; gap: 6px; align-items: center; font-size: 14px; }
    input[type="number"], input[type="text"], select, textarea {
      padding: 6px 8px; background: #0d1117; border: 1px solid #333; color: #eee;
      border-radius: 6px; font-size: 13px;
    }
    input[type="number"] { width: 80px; }
    input[type="text"] { width: 180px; }
    select { padding: 6px 8px; }
    textarea {
      width: 100%; height: 200px; font-family: ui-monospace, Menlo, Monaco, Consolas, monospace;
      font-size: 11px; color: #0f0; resize: vertical; box-sizing: border-box;
    }
    input[type="text"].wide { width: 260px; }
    input[type="file"] { display: none; }

    button { padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; }
    #btn-generate { background: #00d4ff; color: #000; }
    #btn-start    { background: #00ff4c; color: #000; }
    #btn-stop     { background: #ff4b4b; color: #fff; }
    #btn-batch    { background: #ffd700; color: #000; }
    #btn-batch-stop { background: #ff4b4b; color: #fff; }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    #copy-config { background: #16213e; border: 1px solid #444; color: #eee; font-size: 13px; padding: 7px 14px; }
    #copy-config:hover:not(:disabled) { background: #1e2d4a; }
    #download-config { background: #16213e; border: 1px solid #00d4ff; color: #00d4ff; font-size: 13px; padding: 7px 14px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    #download-config:hover:not(:disabled) { background: #1e2d4a; }
    #btn-batch-skip { background: #ff8c00; color: #000; }

    .mat-wrap { display: flex; justify-content: center; margin: 12px 0; }
    #mat {
      display: inline-flex; background: #fff; padding: 24px;
      border-radius: 8px; box-shadow: 0 0 0 1px rgba(0,0,0,.25);
      max-width: 100%; box-sizing: border-box; overflow: hidden;
    }
    #barcode { display: block; }
    #mat.no-mat   { background: transparent; padding: 0; box-shadow: none; border-radius: 0; }
    #mat.all-white { background: #fff; padding: 24px; box-shadow: none; border-radius: 0; }

    #stats { text-align: center; font-size: 13px; color: #b0b0b0; min-height: 18px; margin: 6px 0; font-family: ui-monospace, monospace; }
    #err {
      white-space: pre-wrap; background: #2a1a1a; border: 1px solid #5a2a2a;
      color: #ffd0d0; padding: 10px; border-radius: 8px; display: none;
      margin-top: 10px; font-family: ui-monospace, monospace; font-size: 12px;
    }
    .hint { color: #666; font-size: 12px; margin-top: 6px; }

    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px;
      font-weight: 700; background: #0d1117; color: #888; border: 1px solid #333;
    }
    .badge.ready { background: #0a2a0a; color: #00ff88; border-color: #00ff88; }

    #run-id-display { font-family: ui-monospace, monospace; font-size: 13px; color: #00d4ff; }

    /* Batch mode */
    .batch-section { background: #1a2a1a; border: 1px solid #2a4a2a; }
    #batch-status {
      font-family: ui-monospace, monospace; font-size: 13px; color: #ffd700;
      min-height: 18px; margin: 6px 0; text-align: center;
    }
    #batch-countdown {
      font-family: ui-monospace, monospace; font-size: 24px; font-weight: 800;
      color: #ffd700; text-align: center; min-height: 32px; margin: 4px 0;
    }
    .state-indicator {
      display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 12px;
      font-weight: 700; margin-left: 8px;
    }
    .state-generating { background: #00d4ff22; color: #00d4ff; border: 1px solid #00d4ff; }
    .state-streaming  { background: #00ff4c22; color: #00ff4c; border: 1px solid #00ff4c; }
    .state-pausing    { background: #ffd70022; color: #ffd700; border: 1px solid #ffd700; }
    .state-done       { background: #88888822; color: #888;    border: 1px solid #888; }
  </style>
</head>
<body>
  <h2>QRAM Bench Encoder</h2>

  <!-- Config -->
  <div class="section">
    <h3>Run Config</h3>

    <div class="row">
      <label>Label: <input type="text" id="label" placeholder="e.g. qr-block120-fps12" class="wide"></label>
      <label>Payload: <input type="number" id="payload-size" value="500" min="10" max="100000"> bytes</label>
    </div>

    <div class="row">
      <label>Block: <input type="number" id="blk" value="120" min="50" max="2000"></label>
      <label>FPS: <input type="number" id="fps" value="12" min="1" max="120"></label>
    </div>

    <div class="row">
      <label>Encoding:
        <select id="packet-encoding">
          <option value="base64url" selected>base64url</option>
          <option value="binary">binary</option>
        </select>
      </label>
      <label>Timeout: <input type="number" id="run-timeout" value="120" min="10" max="3600"> sec</label>
    </div>

    <!-- QR options -->
    <div class="row">
      <label>QR EC:
        <select id="qrec">
          <option value="L">L</option>
          <option value="M" selected>M</option>
          <option value="Q">Q</option>
          <option value="H">H</option>
        </select>
      </label>
      <label>Scale: <input type="number" id="qrscale" value="2" min="1" max="20"></label>
    </div>

    <!-- Mat -->
    <div class="row">
      <label>Mat:
        <select id="matmode">
          <option value="white-mat" selected>White Mat</option>
          <option value="none">No Mat</option>
          <option value="all-white">All White</option>
        </select>
      </label>
      <label>Pad: <input type="number" id="matpad" value="24" min="0" max="80"></label>
    </div>

    <!-- Environment -->
    <div class="row">
      <label>Distance: <input type="text" id="env-distance" placeholder="e.g. 60cm" style="width:100px"></label>
      <label>Brightness: <input type="text" id="env-brightness" placeholder="e.g. 80%" style="width:80px"></label>
      <label>Notes: <input type="text" id="env-notes" placeholder="lighting, conditions…" class="wide"></label>
    </div>
  </div>

  <!-- Actions -->
  <div class="row">
    <button id="btn-generate">Generate Payload</button>
    <button id="btn-start" disabled>&#9654; Start</button>
    <button id="btn-stop" disabled>&#9632; Stop</button>
    <span id="run-id-display"></span>
    <span id="ready-badge" class="badge">No payload</span>
  </div>

  <!-- Barcode -->
  <div class="mat-wrap">
    <div id="mat">
      <canvas id="barcode" width="350" height="350"></canvas>
    </div>
  </div>

  <div id="stats"></div>
  <div id="err"></div>

  <!-- Config JSON -->
  <div class="section" id="config-section" style="display:none">
    <h3>Run Config JSON &mdash; copy this before scanning</h3>
    <textarea id="config-json" readonly></textarea>
    <div class="row" style="margin-top:8px">
      <button id="copy-config">Copy Config JSON</button>
      <button id="download-config">⬇ Download Config JSON</button>
      <span class="hint">Paste into the decoder or save for later analysis.</span>
    </div>
  </div>

  <!-- Batch Mode -->
  <div class="section batch-section">
    <h3>Batch Mode</h3>
    <div class="row">
      <button id="btn-batch">Load Batch Config</button>
      <button id="btn-batch-stop" disabled>Stop Batch</button>
      <button id="btn-batch-skip" disabled>Skip to Next →</button>
      <input type="file" id="batch-file-input" accept=".json,application/json">
      <span class="hint">Upload or paste a JSON array of test configs.</span>
    </div>
    <div class="row">
      <textarea id="batch-paste" placeholder="Or paste a JSON array of test configs here..." style="height:80px"></textarea>
    </div>
    <div class="row" id="url-load-row" style="display:none">
      <span class="hint" id="url-load-hint"></span>
    </div>
    <div id="batch-status"></div>
    <div id="batch-countdown"></div>
  </div>

<script>
(() => {
  // === Seeded PRNG (xorshift128) ===
  function createSeededPRNG(seed) {
    // seed is a 32-bit unsigned integer
    let s0 = seed >>> 0;
    let s1 = (seed * 1664525 + 1013904223) >>> 0;
    let s2 = (s1 * 1664525 + 1013904223) >>> 0;
    let s3 = (s2 * 1664525 + 1013904223) >>> 0;
    // Ensure non-zero state
    if ((s0 | s1 | s2 | s3) === 0) s0 = 1;

    return {
      nextUint32() {
        let t = s3;
        const s = s0;
        s3 = s2; s2 = s1; s1 = s0;
        t ^= t << 11;
        t ^= t >>> 8;
        s0 = t ^ s ^ (s >>> 19);
        return s0 >>> 0;
      },
      fillBytes(arr) {
        for (let i = 0; i < arr.length; i += 4) {
          const v = this.nextUint32();
          arr[i]     = v & 0xff;
          if (i + 1 < arr.length) arr[i + 1] = (v >> 8)  & 0xff;
          if (i + 2 < arr.length) arr[i + 2] = (v >> 16) & 0xff;
          if (i + 3 < arr.length) arr[i + 3] = (v >> 24) & 0xff;
        }
        return arr;
      }
    };
  }

  function generateRandomSeed() {
    const buf = new Uint32Array(1);
    crypto.getRandomValues(buf);
    return buf[0];
  }

  // === Elements ===
  const elLabel       = document.getElementById('label');
  const elPayloadSize = document.getElementById('payload-size');
  const elBlk         = document.getElementById('blk');
  const elFPS         = document.getElementById('fps');
  const elPacketEnc   = document.getElementById('packet-encoding');
  const elRunTimeout  = document.getElementById('run-timeout');

  const elQrEc    = document.getElementById('qrec');
  const elQrScale = document.getElementById('qrscale');

  const elMatMode = document.getElementById('matmode');
  const elMatPad  = document.getElementById('matpad');
  const elMat     = document.getElementById('mat');

  const elDistance   = document.getElementById('env-distance');
  const elBrightness = document.getElementById('env-brightness');
  const elNotes      = document.getElementById('env-notes');

  const elGenerate    = document.getElementById('btn-generate');
  const elStart       = document.getElementById('btn-start');
  const elStop        = document.getElementById('btn-stop');
  const elCanvas      = document.getElementById('barcode');
  const elStats       = document.getElementById('stats');
  const elErr         = document.getElementById('err');
  const elConfigJson  = document.getElementById('config-json');
  const elConfigSec   = document.getElementById('config-section');
  const elCopyConfig      = document.getElementById('copy-config');
  const elDownloadConfig  = document.getElementById('download-config');
  const elRunIdDisplay = document.getElementById('run-id-display');
  const elReadyBadge   = document.getElementById('ready-badge');

  // Batch elements
  const elBatchBtn       = document.getElementById('btn-batch');
  const elBatchStop      = document.getElementById('btn-batch-stop');
  const elBatchSkip      = document.getElementById('btn-batch-skip');
  const elBatchFileInput = document.getElementById('batch-file-input');
  const elBatchPaste    = document.getElementById('batch-paste');
  const elBatchStatus   = document.getElementById('batch-status');
  const elBatchCountdown = document.getElementById('batch-countdown');

  // === Run state ===
  let running          = false;
  let cancelRequested  = false;
  let reader           = null;
  let stream           = null;
  let currentPayload   = null;
  let currentRunIdHex  = null;
  let currentRunIdBytes = null;
  let currentConfig    = null;
  let seqNum           = 0;
  let runTimeoutTimer  = null;

  // Batch state
  let batchRunning         = false;
  let batchCancelRequested = false;
  let batchSkipRequested   = false;
  let batchConfigs         = [];
  let batchIndex           = 0;

  // === Helpers ===
  function generateRunId() {
    const bytes = new Uint8Array(4);
    crypto.getRandomValues(bytes);
    const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
    return { hex, bytes };
  }

  async function sha256hex(data) {
    const buf = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(buf), b => b.toString(16).padStart(2, '0')).join('');
  }

  function bytesToBase64Url(u8) {
    let bin = '';
    for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
    return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  // 8-byte bench header: [runId: 4 bytes] [seqNum: 4 bytes big-endian]
  function buildBenchPacket(runIdBytes, seq, qramData) {
    const out = new Uint8Array(4 + 4 + qramData.length);
    out.set(runIdBytes, 0);
    out[4] = (seq >> 24) & 0xff;
    out[5] = (seq >> 16) & 0xff;
    out[6] = (seq >> 8)  & 0xff;
    out[7] = seq & 0xff;
    out.set(qramData, 8);
    return out;
  }

  function formatBytes(n) {
    if (n < 1024) return n + ' B';
    if (n < 1048576) return (n / 1024).toFixed(1) + ' KB';
    return (n / 1048576).toFixed(1) + ' MB';
  }

  function getTimestampStr() {
    const d = new Date();
    return `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}-${String(d.getHours()).padStart(2,'0')}${String(d.getMinutes()).padStart(2,'0')}${String(d.getSeconds()).padStart(2,'0')}`;
  }

  function collectScreenMetadata() {
    return {
      screenWidth:      screen.width,
      screenHeight:     screen.height,
      devicePixelRatio: window.devicePixelRatio || 1,
      colorDepth:       screen.colorDepth,
      userAgent:        navigator.userAgent,
      platform:         navigator.platform || null,
    };
  }

  function showError(msg, errObj) {
    const extra = errObj ? '\n\n' + (errObj.stack || String(errObj)) : '';
    elErr.textContent = String(msg) + extra;
    elErr.style.display = 'block';
    console.error(msg, errObj);
  }
  function clearError() { elErr.textContent = ''; elErr.style.display = 'none'; }

  function setButtons(isRunning, hasPayload) {
    elGenerate.disabled  = isRunning || batchRunning;
    elStart.disabled     = isRunning || batchRunning || !hasPayload;
    elStop.disabled      = !isRunning;
    elBatchBtn.disabled  = isRunning || batchRunning;
    elBatchStop.disabled = !batchRunning;
    elBatchSkip.disabled = !batchRunning;
  }

  // === Mat ===
  function applyMatSettings() {
    const mode = elMatMode.value;
    const pad  = Math.max(0, Math.min(80, parseInt(elMatPad.value, 10) || 0));
    elMat.style.padding = pad + 'px';
    elMat.classList.remove('no-mat', 'all-white');
    if (mode === 'none') {
      elMat.classList.add('no-mat');
      elMat.style.padding = '0';
    } else if (mode === 'all-white') {
      elMat.classList.add('all-white');
    }
    document.body.style.background = mode === 'all-white' ? '#fff' : '#1a1a2e';
    document.body.style.color      = mode === 'all-white' ? '#111' : '#eee';
  }
  elMatMode.addEventListener('change', applyMatSettings);
  elMatPad.addEventListener('input', applyMatSettings);

  // === Canvas ===
  function clearCanvas() {
    const ctx = elCanvas.getContext('2d');
    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, elCanvas.width, elCanvas.height);
    ctx.restore();
    elCanvas.style.width  = '';
    elCanvas.style.height = '';
  }

  // After rendering, fit canvas to container if needed
  function fitCanvasToContainer() {
    const cw = elCanvas.width;
    const ch = elCanvas.height;
    if (!cw || !ch) return;
    // Get available width from the mat container (minus padding)
    const matStyle = getComputedStyle(elMat);
    const padL = parseFloat(matStyle.paddingLeft) || 0;
    const padR = parseFloat(matStyle.paddingRight) || 0;
    const available = elMat.parentElement.clientWidth - padL - padR;
    if (cw > available && available > 0) {
      // Scale down to fit
      const ratio = available / cw;
      elCanvas.style.width  = Math.floor(cw * ratio) + 'px';
      elCanvas.style.height = Math.floor(ch * ratio) + 'px';
    } else {
      // Display at natural size
      elCanvas.style.width  = cw + 'px';
      elCanvas.style.height = ch + 'px';
    }
  }

  // === Render barcode (QR only via qrcode.min.js) ===
  async function renderPacketAsBarcode(textOrBytes, encoding) {
    if (typeof QRCode === 'undefined') throw new Error('qrcode.min.js not loaded');
    const scale = Math.max(1, Math.min(20, parseInt(elQrScale.value, 10) || 2));
    const ecLevel = elQrEc.value;

    if (encoding === 'binary') {
      await QRCode.toCanvas(elCanvas, [{ data: textOrBytes, mode: 'byte' }], {
        errorCorrectionLevel: ecLevel,
        scale,
        margin: 1,
      });
    } else {
      await QRCode.toCanvas(elCanvas, textOrBytes, {
        errorCorrectionLevel: ecLevel,
        scale,
        margin: 1,
      });
    }
    fitCanvasToContainer();
  }

  // === Build config from UI or from batch config object ===
  function buildConfigFromUI() {
    const blockSize = Math.max(50, Math.min(2000, parseInt(elBlk.value, 10) || 120));
    const fps       = Math.max(1, Math.min(60, parseInt(elFPS.value, 10) || 12));
    const payloadSize = Math.max(10, Math.min(100000, parseInt(elPayloadSize.value, 10) || 500));
    const packetEncoding = elPacketEnc.value;
    const timeoutSec = Math.max(10, parseInt(elRunTimeout.value, 10) || 120);

    const cfg = {
      label:          elLabel.value.trim() || null,
      encoderLib:     'qrcode.min.js',
      barcodeType:    'qrcode',
      packetEncoding: packetEncoding,
      blockSize,
      fps,
      payloadSize,
      timeoutSec,
      matMode:        elMatMode.value,
      matPad:         Math.max(0, parseInt(elMatPad.value, 10) || 24),
      env: {
        distance:   elDistance.value.trim()   || null,
        brightness: elBrightness.value.trim() || null,
        notes:      elNotes.value.trim()      || null,
      },
    };

    cfg.ecLevel = elQrEc.value;
    cfg.scale   = Math.max(1, Math.min(20, parseInt(elQrScale.value, 10) || 2));

    return cfg;
  }

  // Apply a batch config object to the UI
  // Non-QR barcodeType values are coerced to 'qrcode' with a warning.
  function applyConfigToUI(cfg) {
    if (cfg.barcodeType != null && cfg.barcodeType !== 'qrcode') {
      showError(`Batch config barcodeType "${cfg.barcodeType}" is not supported — coercing to "qrcode".`);
    }
    if (cfg.label != null)         elLabel.value       = cfg.label;
    if (cfg.payloadSize != null)   elPayloadSize.value = cfg.payloadSize;
    if (cfg.blockSize != null)     elBlk.value         = cfg.blockSize;
    if (cfg.fps != null)           elFPS.value         = cfg.fps;
    if (cfg.packetEncoding != null) elPacketEnc.value  = cfg.packetEncoding;
    if (cfg.timeoutSec != null)    elRunTimeout.value  = cfg.timeoutSec;
    if (cfg.matMode != null)       elMatMode.value     = cfg.matMode;
    if (cfg.matPad != null)        elMatPad.value      = cfg.matPad;

    if (cfg.ecLevel != null)       elQrEc.value        = cfg.ecLevel;
    if (cfg.scale != null)         elQrScale.value     = cfg.scale;

    if (cfg.env) {
      if (cfg.env.distance != null)   elDistance.value   = cfg.env.distance;
      if (cfg.env.brightness != null) elBrightness.value = cfg.env.brightness;
      if (cfg.env.notes != null)      elNotes.value      = cfg.env.notes;
    }

    applyMatSettings();
  }

  // === Generate payload for a run (returns { payload, config }) ===
  async function generatePayloadForRun(cfgOverrides) {
    const baseCfg = cfgOverrides || buildConfigFromUI();
    const payloadSize = baseCfg.payloadSize || 500;
    const blockSize   = baseCfg.blockSize || 120;

    // Generate seeded random payload
    const randomSeed = (cfgOverrides && cfgOverrides.randomSeed != null)
      ? cfgOverrides.randomSeed
      : generateRandomSeed();
    const prng    = createSeededPRNG(randomSeed);
    const payload = new Uint8Array(payloadSize);
    prng.fillBytes(payload);

    const { hex: runIdHex, bytes: runIdBytes } = generateRunId();
    const payloadHash = await sha256hex(payload);
    const blocks      = Math.ceil(payloadSize / blockSize);

    const config = {
      runId:           runIdHex,
      label:           baseCfg.label || null,
      timestamp:       new Date().toISOString(),
      encoderLib:      'qrcode.min.js',
      encoderLibVersion: detectEncoderLibVersion(),
      barcodeType:     'qrcode',
      packetEncoding:  baseCfg.packetEncoding || 'base64url',
      blockSize,
      fps:             baseCfg.fps || 12,
      blocks,
      payloadSize,
      payloadHash,
      randomSeed,
      timeoutSec:      baseCfg.timeoutSec || 120,
      matMode:         baseCfg.matMode || 'white-mat',
      matPad:          baseCfg.matPad != null ? baseCfg.matPad : 24,
      env:             baseCfg.env || {},
      screen:          collectScreenMetadata(),
    };

    config.ecLevel = baseCfg.ecLevel || 'M';
    config.scale   = baseCfg.scale != null ? baseCfg.scale : 2;

    return { payload, runIdHex, runIdBytes, config };
  }

  function detectEncoderLibVersion() {
    if (typeof QRCode !== 'undefined' && QRCode.version) return 'qrcode.min.js ' + QRCode.version;
    return 'qrcode.min.js (version unknown)';
  }

  // === Generate payload (single run, manual) ===
  elGenerate.addEventListener('click', async () => {
    if (running || batchRunning) return;
    clearError();

    try {
      const { payload, runIdHex, runIdBytes, config } = await generatePayloadForRun();

      currentPayload    = payload;
      currentRunIdHex   = runIdHex;
      currentRunIdBytes = runIdBytes;
      currentConfig     = config;
      seqNum            = 0;

      elConfigJson.value = JSON.stringify(config, null, 2);
      elConfigSec.style.display = '';

      elRunIdDisplay.textContent = 'Run: ' + runIdHex;
      elReadyBadge.textContent = 'Ready';
      elReadyBadge.className = 'badge ready';

      elStats.textContent = `Payload generated — ${formatBytes(config.payloadSize)} | ${config.blocks} blocks | seed: ${config.randomSeed} | hash: ${config.payloadHash.slice(0, 12)}…`;
      setButtons(false, true);
      clearCanvas();
    } catch (e) {
      showError('Failed to generate payload', e);
    }
  });

  // === Start streaming (returns a promise that resolves when stopped) ===
  async function startStreaming(payload, runIdBytes, runIdHex, config) {
    if (!window.qram) throw new Error("qram library didn't load.");

    const blockSize = config.blockSize;
    const fps       = config.fps;
    const delay     = 1000 / fps;
    const encoding  = config.packetEncoding || 'base64url';
    const timeoutMs = (config.timeoutSec || 120) * 1000;

    let enc;
    try { enc = new qram.Encoder({ data: payload, blockSize }); }
    catch (e) { throw new Error('Failed to create qram.Encoder: ' + e.message); }

    try {
      stream = await enc.createReadableStream();
      reader = stream.getReader();
    } catch (e) {
      throw new Error('Failed to create QRAM stream: ' + e.message);
    }

    running         = true;
    cancelRequested = false;
    seqNum          = 0;
    setButtons(true, true);

    const blocks    = config.blocks;
    const payloadSz = payload.length;
    let timedOut    = false;
    let canvasCaptured = false;

    // Set up per-run timeout
    runTimeoutTimer = setTimeout(() => {
      timedOut = true;
      cancelRequested = true;
      try { reader?.cancel(); } catch (_) {}
      try { stream?.cancel?.(); } catch (_) {}
    }, timeoutMs);

    try {
      while (!cancelRequested) {
        const { value: pkt, done } = await reader.read();
        if (done) break;

        const benchPkt = buildBenchPacket(runIdBytes, seqNum, pkt.data);

        if (encoding === 'binary') {
          try { await renderPacketAsBarcode(benchPkt, 'binary'); }
          catch (e) { showError('Render error: ' + e.message, e); break; }
        } else {
          const text = bytesToBase64Url(benchPkt);
          try { await renderPacketAsBarcode(text, 'base64url'); }
          catch (e) { showError('Render error: ' + e.message, e); break; }
        }

        // Capture rendered canvas dimensions after first successful render (Task 4)
        if (!canvasCaptured) {
          canvasCaptured = true;
          config.renderedCanvasSize = { width: elCanvas.width, height: elCanvas.height };
          elConfigJson.value = JSON.stringify(config, null, 2);
        }

        seqNum++;
        const cs = config.renderedCanvasSize;
        const canvasStr = cs ? ` | canvas ${cs.width}×${cs.height}px` : '';
        elStats.textContent = `Streaming — run ${runIdHex} | pkt #${seqNum} | ${formatBytes(payloadSz)} | ${blocks} blocks${canvasStr}`;

        await new Promise(ok => setTimeout(ok, delay));
      }
    } catch (e) {
      if (!cancelRequested) showError('Streaming loop error', e);
    } finally {
      if (runTimeoutTimer) { clearTimeout(runTimeoutTimer); runTimeoutTimer = null; }
      try { await reader?.cancel(); } catch (_) {}
      try { await stream?.cancel?.(); } catch (_) {}
      reader = null;
      stream = null;
      running         = false;
      cancelRequested = false;
      setButtons(false, !!currentPayload);
      const reason = timedOut ? ' — TIMEOUT' : '';
      elStats.textContent += ` — stopped at pkt #${seqNum}${reason}`;
    }

    return { timedOut, totalPackets: seqNum };
  }

  // === Start (single manual run) ===
  elStart.addEventListener('click', async () => {
    if (running || !currentPayload || batchRunning) return;
    clearError();
    clearCanvas();
    applyMatSettings();

    try {
      await startStreaming(currentPayload, currentRunIdBytes, currentRunIdHex, currentConfig);
    } catch (e) {
      showError(e.message, e);
    }
  });

  // === Stop ===
  elStop.addEventListener('click', () => {
    cancelRequested = true;
    if (runTimeoutTimer) { clearTimeout(runTimeoutTimer); runTimeoutTimer = null; }
    try { reader?.cancel(); } catch (_) {}
    try { stream?.cancel?.(); } catch (_) {}
  });

  // === Copy config ===
  elCopyConfig.addEventListener('click', async () => {
    const text = elConfigJson.value;
    try {
      await navigator.clipboard.writeText(text);
      elCopyConfig.textContent = 'Copied!';
      setTimeout(() => elCopyConfig.textContent = 'Copy Config JSON', 2500);
    } catch (_) {
      elConfigJson.select();
      document.execCommand('copy');
    }
  });

  // === Download Config JSON (Task 3) ===
  elDownloadConfig.addEventListener('click', () => {
    const text = elConfigJson.value;
    if (!text) return;
    let filename;
    try {
      const parsed = JSON.parse(text);
      if (Array.isArray(parsed)) {
        filename = `qram-encoder-batch-${getTimestampStr()}.json`;
      } else {
        const rid = (parsed && parsed.runId) || currentRunIdHex;
        filename = rid ? `qram-encoder-${rid}.json` : 'qram-encoder-config.json';
      }
    } catch (_) {
      filename = 'qram-encoder-config.json';
    }
    const blob = new Blob([text], { type: 'application/json' });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href     = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  });

  // === Batch Mode ===
  function parseBatchConfigs(jsonStr) {
    const arr = JSON.parse(jsonStr);
    if (!Array.isArray(arr)) throw new Error('Batch config must be a JSON array');
    if (arr.length === 0) throw new Error('Batch config array is empty');
    return arr;
  }

  async function runBatch(configs) {
    batchRunning         = true;
    batchCancelRequested = false;
    batchSkipRequested   = false;
    batchConfigs         = configs;
    batchIndex           = 0;
    setButtons(false, false);

    const allConfigs = [];

    for (let i = 0; i < configs.length; i++) {
      if (batchCancelRequested) break;
      batchIndex = i;
      batchSkipRequested = false; // Reset at start of each run (Task 9)

      const batchCfg = configs[i];
      const label = batchCfg.label || `Run ${i + 1}`;

      // Show batch progress
      elBatchStatus.innerHTML = `<strong>Run ${i + 1} of ${configs.length}</strong> — ${label} <span class="state-indicator state-generating">generating</span>`;
      elBatchCountdown.textContent = '';

      // Apply config to UI
      applyConfigToUI(batchCfg);

      // Generate payload
      const { payload, runIdHex, runIdBytes, config } = await generatePayloadForRun(batchCfg);

      currentPayload    = payload;
      currentRunIdHex   = runIdHex;
      currentRunIdBytes = runIdBytes;
      currentConfig     = config;

      allConfigs.push(config);

      // Update config display
      elConfigJson.value = JSON.stringify(config, null, 2);
      elConfigSec.style.display = '';
      elRunIdDisplay.textContent = 'Run: ' + runIdHex;
      elReadyBadge.textContent = `Batch ${i + 1}/${configs.length}`;
      elReadyBadge.className = 'badge ready';

      // Stream
      elBatchStatus.innerHTML = `<strong>Run ${i + 1} of ${configs.length}</strong> — ${label} <span class="state-indicator state-streaming">streaming</span>`;

      clearCanvas();
      applyMatSettings();

      try {
        await startStreaming(payload, runIdBytes, runIdHex, config);
      } catch (e) {
        showError('Batch run error: ' + e.message, e);
      }

      if (batchCancelRequested) break;

      // Pause between runs (3-5 seconds with countdown)
      if (i < configs.length - 1) {
        elBatchStatus.innerHTML = `<strong>Run ${i + 1} of ${configs.length} complete</strong> — ${label} <span class="state-indicator state-pausing">pausing</span>`;
        clearCanvas();

        const pauseSec = 4;
        for (let s = pauseSec; s > 0; s--) {
          if (batchCancelRequested || batchSkipRequested) break;
          elBatchCountdown.textContent = `Next run in ${s}...`;
          await new Promise(ok => setTimeout(ok, 1000));
        }
        elBatchCountdown.textContent = '';
      }
    }

    // Done
    batchRunning         = false;
    batchCancelRequested = false;
    batchSkipRequested   = false;
    elBatchStatus.innerHTML = `<strong>Batch complete</strong> — ${configs.length} runs <span class="state-indicator state-done">done</span>`;
    elBatchCountdown.textContent = '';
    setButtons(false, !!currentPayload);

    // Show all configs as JSON array
    elConfigJson.value = JSON.stringify(allConfigs, null, 2);
    elConfigSec.style.display = '';
  }

  elBatchBtn.addEventListener('click', () => {
    // Try paste area first, then file input
    const pasteText = elBatchPaste.value.trim();
    if (pasteText) {
      try {
        const configs = parseBatchConfigs(pasteText);
        clearError();
        runBatch(configs);
      } catch (e) {
        showError('Invalid batch JSON: ' + e.message, e);
      }
    } else {
      elBatchFileInput.click();
    }
  });

  elBatchFileInput.addEventListener('change', async () => {
    const file = elBatchFileInput.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const configs = parseBatchConfigs(text);
      clearError();
      elBatchPaste.value = text;
      runBatch(configs);
    } catch (e) {
      showError('Invalid batch file: ' + e.message, e);
    }
    elBatchFileInput.value = '';
  });

  elBatchStop.addEventListener('click', () => {
    batchCancelRequested = true;
    cancelRequested = true;
    if (runTimeoutTimer) { clearTimeout(runTimeoutTimer); runTimeoutTimer = null; }
    try { reader?.cancel(); } catch (_) {}
    try { stream?.cancel?.(); } catch (_) {}
    elBatchStatus.innerHTML += ' — <strong>STOPPED</strong>';
  });

  // Skip to Next — cancels current run or countdown, advances batch (Task 2)
  elBatchSkip.addEventListener('click', () => {
    if (!batchRunning) return;
    batchSkipRequested = true;
    if (running) {
      // Currently streaming — cancel the active stream (not the whole batch)
      cancelRequested = true;
      if (runTimeoutTimer) { clearTimeout(runTimeoutTimer); runTimeoutTimer = null; }
      try { reader?.cancel(); } catch (_) {}
      try { stream?.cancel?.(); } catch (_) {}
    }
    // If in countdown, batchSkipRequested alone will break the countdown loop
  });

  // Init
  clearCanvas();
  applyMatSettings();
  setButtons(false, false);

  // === URL param auto-load: ?batch=filename.json[&autorun] ===
  (async () => {
    const params   = new URLSearchParams(window.location.search);
    const batchUrl = params.get('batch');
    if (!batchUrl) return;

    const elUrlRow  = document.getElementById('url-load-row');
    const elUrlHint = document.getElementById('url-load-hint');
    elUrlRow.style.display = '';
    elUrlHint.textContent  = `⏳ Loading batch config: ${batchUrl}…`;

    // Resolve relative to current page location
    let resolvedUrl;
    try {
      resolvedUrl = new URL(batchUrl, window.location.href).href;
    } catch (_) {
      elUrlHint.textContent = `❌ Invalid URL: ${batchUrl}`;
      return;
    }

    let configs;
    try {
      const res = await fetch(resolvedUrl);
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
      const text = await res.text();
      configs = parseBatchConfigs(text);
      elBatchPaste.value = text;
    } catch (e) {
      elUrlHint.textContent = `❌ Failed to load "${batchUrl}": ${e.message}`;
      return;
    }

    const autorun = params.has('autorun');
    elUrlHint.innerHTML = `✅ Loaded <strong>${configs.length} run(s)</strong> from <code>${batchUrl}</code>${autorun ? ' — autorun starting…' : ' — click <strong>Load Batch Config</strong> to start.'}`;

    if (autorun) {
      // Small delay so the page renders the status message first
      await new Promise(ok => setTimeout(ok, 600));
      clearError();
      runBatch(configs);
    }
  })();
})();
</script>
</body>
</html>
