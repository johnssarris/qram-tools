<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="QRAM">
  <meta name="theme-color" content="#1a1a2e">
  <title>QRAM</title>
  <link rel="manifest" href="manifest.json">

  <!-- Shared libraries -->
  <script src="./libs/qram.min.js"></script>
  <script src="./libs/pako.min.js"></script>
  <script src="./libs/qram-compress.js"></script>
  <script src="./libs/qram-utils.js"></script>
  <!-- Encoder -->
  <script src="./libs/qrcode.min.js"></script>
  <!-- Decoder -->
  <script src="./libs/jsQR.js"></script>
  <script src="./libs/qram-scan.js"></script>

  <style>
    /* â”€â”€ Reset & base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 15px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    /* â”€â”€ Page-level Encode / Decode tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .page-tabs { display: flex; gap: 0; margin-bottom: 20px; }

    .page-tab {
      flex: 1;
      text-align: center;
      padding: 12px 0;
      background: #16213e;
      color: #888;
      border: 1px solid #333;
      cursor: pointer;
      font-size: 15px;
      font-weight: 700;
      transition: background .15s, color .15s, border-color .15s;
      font-family: inherit;
    }

    .page-tab:first-child { border-radius: 10px 0 0 10px; }
    .page-tab:last-child  { border-radius: 0 10px 10px 0; }

    .page-tab.active { background: #00d4ff; color: #000; border-color: #00d4ff; }
    .page-tab:not(.active):hover { background: #1e2d4a; color: #ccc; }

    /* â”€â”€ Decoder styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #video-container {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    #video { width: 100%; height: 100%; object-fit: cover; }
    #canvas { display: none; }

    #overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    #scan-region {
      width: 75%; height: 75%;
      border: 3px solid #00d4ff;
      border-radius: 12px;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
    }

    .status-box {
      background: #16213e;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 12px;
    }

    .status-label { font-size: 0.8rem; color: #888; margin-bottom: 5px; }
    .status-value { font-size: 1.1rem; font-weight: 600; }

    #progress-bar {
      width: 100%; height: 10px;
      background: #16213e;
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    #progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #00d4ff, #00ff88);
      width: 0%;
      transition: width 0.2s ease;
    }

    .stats-row { display: flex; gap: 10px; margin-bottom: 12px; }

    .stat-box {
      flex: 1;
      background: #16213e;
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }

    .stat-value { font-size: 1.3rem; font-weight: bold; color: #00d4ff; }
    .stat-label { font-size: 0.7rem; color: #888; margin-top: 3px; }
    #speed-display { font-size: 0.85rem; white-space: pre-line; line-height: 1.4; }

    #result-container {
      display: none;
      background: #16213e;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 12px;
    }

    #result-container.show { display: block; }

    #result {
      width: 100%; height: 180px;
      background: #0d1117;
      border: 1px solid #333;
      border-radius: 8px;
      color: #00ff88;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 11px;
      padding: 10px;
      resize: vertical;
    }

    .file-result { text-align: center; padding: 20px 10px; }
    .file-result-icon { font-size: 48px; margin-bottom: 10px; }
    .file-result-name { font-size: 1rem; font-weight: 600; color: #00ff88; word-break: break-all; margin-bottom: 5px; }
    .file-result-size { font-size: 0.85rem; color: #888; }

    .btn {
      width: 100%; padding: 14px;
      border: none; border-radius: 10px;
      font-size: 1rem; font-weight: 600;
      cursor: pointer; margin-bottom: 8px;
      transition: transform 0.1s;
    }

    .btn:active { transform: scale(0.98); }
    .btn-success { background: #00ff88; color: #000; }
    .btn-secondary { background: #16213e; color: #eee; }

    #error-msg {
      background: #ff4444; color: #fff;
      padding: 10px 15px; border-radius: 8px;
      margin-bottom: 12px; display: none; font-size: 0.9rem;
    }

    #error-msg.show { display: block; }

    .scan-indicator {
      position: absolute; bottom: 10px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 255, 136, 0.9); color: #000;
      padding: 5px 12px; border-radius: 20px;
      font-size: 0.75rem; font-weight: 600;
      opacity: 0; transition: opacity 0.1s;
    }

    .scan-indicator.flash { opacity: 1; }

    /* â”€â”€ Encoder styles (scoped to #panel-encode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #panel-encode { font-family: system-ui, sans-serif; }

    #panel-encode h2 { margin: 0 0 14px 0; font-size: 1.2rem; }

    #panel-encode textarea {
      width: 100%; height: 220px;
      background: #0d1117; color: #0f0;
      border: 1px solid #333; padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px; border-radius: 8px;
    }

    #start {
      display: block; width: 100%;
      padding: 14px; margin-top: 12px;
      border: none; border-radius: 10px;
      font-size: 1.05rem; font-weight: 700; cursor: pointer;
      background: #00ff4c; color: #000;
      transition: transform .1s;
    }
    #start:active { transform: scale(0.98); }
    #start:disabled { opacity: .55; cursor: not-allowed; }

    #stop {
      display: block; width: 100%;
      padding: 16px; margin-top: 14px;
      border: none; border-radius: 10px;
      font-size: 1.1rem; font-weight: 700; cursor: pointer;
      background: #ff4b4b; color: #fff;
      transition: transform .1s;
    }
    #stop:active { transform: scale(0.98); }

    #panel-encode canvas {
      display: block;
      width: 100%; max-width: 350px; aspect-ratio: 1;
      margin: 0 auto 4px;
      background: #fff; border-radius: 8px;
    }

    #stats {
      text-align: center; font-size: 13px; color: #b7b7b7;
      padding: 6px 0 2px; min-height: 22px;
    }

    .enc-settings { margin-top: 10px; }
    .enc-settings label { font-size: 13px; }

    #err {
      white-space: pre-wrap; background: #2a1a1a; border: 1px solid #5a2a2a;
      color: #ffd0d0; padding: 10px; border-radius: 8px; display: none;
      margin-top: 10px; font-family: ui-monospace, monospace; font-size: 12px;
    }

    .row { display: flex; flex-wrap: wrap; gap: 14px; align-items: center; margin: 12px 0; }
    .row label { color: #c8c8c8; display: flex; gap: 6px; align-items: center; }

    .row input[type="number"] {
      width: 80px; padding: 6px 8px;
      background: #0d1117; border: 1px solid #333; color: #eee; border-radius: 6px;
    }

    /* Encoder inner Text / File mode tabs */
    .mode-tabs { display: flex; gap: 0; margin-bottom: 12px; }
    .mode-tab {
      padding: 10px 24px; background: #16213e; color: #888;
      border: 1px solid #333; cursor: pointer; font-size: 14px; font-weight: 600;
      transition: all .15s;
    }
    .mode-tab:first-child { border-radius: 8px 0 0 8px; }
    .mode-tab:last-child  { border-radius: 0 8px 8px 0; }
    .mode-tab.active      { background: #00d4ff; color: #000; border-color: #00d4ff; }
    .mode-tab:not(.active):hover { background: #1e2d4a; }

    /* Drop zone */
    #drop-zone {
      width: 100%; height: 220px;
      background: #0d1117; border: 2px dashed #444; border-radius: 8px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 10px; cursor: pointer; transition: border-color .2s, background .2s;
    }
    #drop-zone.active   { border-color: #00d4ff; background: #0d1117cc; }
    #drop-zone.has-file { border-color: #00ff88; border-style: solid; }
    #drop-zone .drop-icon { font-size: 36px; color: #555; }
    #drop-zone .drop-text { color: #888; font-size: 14px; }
    #drop-zone .file-info { color: #00ff88; font-size: 14px; font-weight: 600; }
    #drop-zone .file-size { color: #888; font-size: 12px; }
    #drop-zone .drop-hint { color: #666; font-size: 11px; }
    #file-input { display: none; }

    .auto-label { color: #c8c8c8; display: flex; gap: 4px; align-items: center; font-size: 13px; cursor: pointer; }
    .auto-label input[type="checkbox"] { accent-color: #00d4ff; width: 16px; height: 16px; cursor: pointer; }
    #blk:disabled { opacity: .6; cursor: not-allowed; }

    #data-size { font-size: 12px; color: #888; margin-top: 4px; }
  </style>
</head>

<body>
  <div class="container">

    <!-- Page-level tab switcher -->
    <div class="page-tabs" role="tablist">
      <button class="page-tab"        data-page="encode" role="tab">Encode</button>
      <button class="page-tab active" data-page="decode" role="tab">Decode</button>
    </div>

    <!-- â”€â”€ Encoder panel (hidden by default) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="panel-encode" style="display:none">

      <!-- Setup view: shown before encoding starts -->
      <div id="enc-setup">
        <h2>QRAM Encoder</h2>

        <div class="mode-tabs">
          <div class="mode-tab active" data-mode="text">Text</div>
          <div class="mode-tab" data-mode="file">File</div>
        </div>

        <div id="text-input">
          <textarea id="txt" placeholder="Paste text here..."></textarea>
        </div>

        <div id="file-input-area" style="display:none">
          <div id="drop-zone">
            <div class="drop-icon">ğŸ“</div>
            <div class="drop-text">Drop a file here or click to browse</div>
            <div class="drop-hint">SSH keys, configs, small files</div>
          </div>
          <input type="file" id="file-input" />
        </div>

        <div id="data-size"></div>

        <div class="row enc-settings">
          <label>FPS:<input type="number" id="fps" value="20" min="1" max="60"></label>
          <label>Block:<input type="number" id="blk" value="200" min="50" max="5000"></label>
          <label class="auto-label"><input type="checkbox" id="auto-blk"> Auto</label>
          <label class="auto-label"><input type="checkbox" id="compress" checked> Compress</label>
        </div>

        <button id="start">&#9654; Start Encoding</button>
      </div><!-- /#enc-setup -->

      <!-- Error box: always visible, shown between views if needed -->
      <div id="err"></div>

      <!-- Live view: shown while encoding is running -->
      <div id="enc-live" style="display:none">
        <canvas id="qr" width="350" height="350"></canvas>
        <div id="stats"></div>
        <button id="stop">&#9632; Stop</button>
      </div><!-- /#enc-live -->

    </div><!-- /#panel-encode -->

    <!-- â”€â”€ Decoder panel (visible by default) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div id="panel-decode">
      <div id="error-msg"></div>

      <div id="video-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="overlay">
          <div id="scan-region"></div>
        </div>
        <div id="scan-indicator" class="scan-indicator">Packet</div>
      </div>

      <div id="progress-bar">
        <div id="progress-fill"></div>
      </div>

      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-value" id="blocks-received">0</div>
          <div class="stat-label">Decoded</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="blocks-total">?</div>
          <div class="stat-label">Blocks</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="packets-scanned">0 / ?</div>
          <div class="stat-label">Frames</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="speed-display">--</div>
          <div class="stat-label">Speed</div>
        </div>
      </div>

      <div class="status-box">
        <div class="status-label">Status</div>
        <div class="status-value" id="status">Initializing camera...</div>
      </div>

      <div id="result-container">
        <div class="status-label" id="result-label">Decoded Content</div>
        <div id="text-result">
          <textarea id="result" readonly></textarea>
        </div>
        <div id="file-result" class="file-result" style="display:none">
          <div class="file-result-icon">ğŸ“„</div>
          <div class="file-result-name" id="file-result-name"></div>
          <div class="file-result-size" id="file-result-size"></div>
        </div>
      </div>

      <button id="copy-btn" class="btn btn-success" style="display: none;">
        Copy to Clipboard
      </button>

      <button id="download-btn" class="btn btn-success" style="display: none;">
        Download File
      </button>

      <button id="save-btn" class="btn btn-success" style="display: none;">
        Save as File
      </button>

      <button id="reset-btn" class="btn btn-secondary">
        Reset &amp; Scan Again
      </button>
    </div><!-- /#panel-decode -->

  </div><!-- /.container -->

  <script>
    // â”€â”€ Zone A: Page-tab controller â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const pageTabs = (() => {
      const tabs     = document.querySelectorAll('.page-tab');
      const panelEnc = document.getElementById('panel-encode');
      const panelDec = document.getElementById('panel-decode');

      let _onEncDeactivate = null;
      let _onDecActivate   = null;
      let _onDecDeactivate = null;
      let current = 'decode';

      function switchTo(page) {
        if (page === current) return;
        if (current === 'encode') { _onEncDeactivate && _onEncDeactivate(); }
        else                      { _onDecDeactivate && _onDecDeactivate(); }
        panelEnc.style.display = page === 'encode' ? '' : 'none';
        panelDec.style.display = page === 'decode' ? '' : 'none';
        tabs.forEach(t => t.classList.toggle('active', t.dataset.page === page));
        current = page;
        if (page === 'decode') { _onDecActivate && _onDecActivate(); }
      }

      tabs.forEach(tab => tab.addEventListener('click', () => switchTo(tab.dataset.page)));

      return {
        onEncodeDeactivate: fn => { _onEncDeactivate = fn; },
        onDecodeActivate:   fn => { _onDecActivate   = fn; },
        onDecodeDeactivate: fn => { _onDecDeactivate = fn; },
      };
    })();

    // â”€â”€ Zone B: Encoder IIFE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (() => {
      const elTxt      = document.getElementById('txt');
      const elFPS      = document.getElementById('fps');
      const elBlk      = document.getElementById('blk');
      const elAutoBlk  = document.getElementById('auto-blk');
      const elCompress = document.getElementById('compress');
      const elStart    = document.getElementById('start');
      const elStop     = document.getElementById('stop');
      const elStats    = document.getElementById('stats');
      const elErr      = document.getElementById('err');
      const elCanvas   = document.getElementById('qr');
      const elDataSize = document.getElementById('data-size');
      const elDropZone = document.getElementById('drop-zone');
      const elFileInput     = document.getElementById('file-input');
      const elTextInput     = document.getElementById('text-input');
      const elFileInputArea = document.getElementById('file-input-area');
      const modeTabs = document.querySelectorAll('.mode-tab');

      let running = false;
      let cancelRequested = false;
      let reader = null;
      let stream = null;

      let currentMode = 'text';
      let loadedFile = null;

      const FILE_MAGIC = new Uint8Array([0x51, 0x52, 0x41, 0x4D, 0x46]);

      // --- Mode switching ---
      function handleModeSwitch(mode) {
        if (running) return;
        if (mode === currentMode) return;
        currentMode = mode;
        modeTabs.forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
        elTextInput.style.display = mode === 'text' ? '' : 'none';
        elFileInputArea.style.display = mode === 'file' ? '' : 'none';
        updateDataSize();
      }

      modeTabs.forEach(tab => {
        tab.addEventListener('click', () => handleModeSwitch(tab.dataset.mode));
      });

      // --- File handling ---
      function handleFile(file) {
        if (!file) return;
        if (file.size > 5000 * 1024) {
          showError('File too large. Keep files under 100 KB for practical QR transfer.');
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          loadedFile = {
            name: file.name,
            data: new Uint8Array(reader.result)
          };
          elDropZone.classList.add('has-file');
          elDropZone.innerHTML = '';
          const _icon = Object.assign(document.createElement('div'), { className: 'drop-icon', textContent: '\u2705' });
          const _info = Object.assign(document.createElement('div'), { className: 'file-info', textContent: file.name });
          const _size = Object.assign(document.createElement('div'), { className: 'file-size', textContent: formatBytes(file.size) });
          const _hint = Object.assign(document.createElement('div'), { className: 'drop-hint', textContent: 'Click or drop to replace' });
          elDropZone.append(_icon, _info, _size, _hint);
          updateDataSize();
        };
        reader.onerror = () => showError('Failed to read file.');
        reader.readAsArrayBuffer(file);
      }

      elDropZone.addEventListener('click', () => elFileInput.click());

      elDropZone.addEventListener('dragover', e => {
        e.preventDefault();
        elDropZone.classList.add('active');
      });

      elDropZone.addEventListener('dragleave', () => {
        elDropZone.classList.remove('active');
      });

      elDropZone.addEventListener('drop', e => {
        e.preventDefault();
        elDropZone.classList.remove('active');
        if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
      });

      elFileInput.addEventListener('change', () => {
        if (elFileInput.files.length > 0) handleFile(elFileInput.files[0]);
      });

      elTxt.addEventListener('dragover', e => {
        if (e.dataTransfer.types.includes('Files')) e.preventDefault();
      });

      elTxt.addEventListener('drop', e => {
        if (e.dataTransfer.files.length > 0) {
          e.preventDefault();
          currentMode = 'file';
          modeTabs.forEach(t => t.classList.toggle('active', t.dataset.mode === 'file'));
          elTextInput.style.display = 'none';
          elFileInputArea.style.display = '';
          handleFile(e.dataTransfer.files[0]);
        }
      });

      // --- Auto block size ---
      function autoBlockSize(dataLength) {
        if (dataLength <= 50)     return 50;
        if (dataLength <= 600)    return dataLength;
        if (dataLength <= 1200)   return Math.ceil(dataLength / 2);
        if (dataLength <= 5000)   return 400;
        if (dataLength <= 20000)  return 500;
        if (dataLength <= 100000) return 600;
        return 700;
      }

      elAutoBlk.addEventListener('change', () => {
        elBlk.disabled = elAutoBlk.checked;
        if (elAutoBlk.checked) updateDataSize();
      });

      elBlk.disabled = elAutoBlk.checked;
      elTxt.addEventListener('input', updateDataSize);

      function updateDataSize() {
        let size = 0;
        if (currentMode === 'text') {
          const txt = elTxt.value || '';
          if (txt) size = new TextEncoder().encode(txt).length;
        } else if (loadedFile) {
          const nameBytes = new TextEncoder().encode(loadedFile.name).length;
          size = FILE_MAGIC.length + 2 + nameBytes + loadedFile.data.length;
        }

        if (size > 0) {
          elDataSize.textContent = `Data: ${formatBytes(size)}`;
          if (elAutoBlk.checked) elBlk.value = autoBlockSize(size);
        } else {
          elDataSize.textContent = '';
        }
      }

      // --- Helpers ---
      const { formatBytes } = qramUtils;

      function showError(msg, errObj) {
        const extra = errObj ? ('\n\n' + (errObj.stack || String(errObj))) : '';
        elErr.textContent = String(msg) + extra;
        elErr.style.display = 'block';
        console.error(msg, errObj);
      }

      function clearError() {
        elErr.textContent = '';
        elErr.style.display = 'none';
      }

      const encSetup = document.getElementById('enc-setup');
      const encLive  = document.getElementById('enc-live');

      function setEncodeView(isRunning) {
        encSetup.style.display = isRunning ? 'none' : '';
        encLive.style.display  = isRunning ? '' : 'none';
        if (isRunning) {
          elCanvas.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }

      function clearCanvas() {
        const ctx = elCanvas.getContext('2d');
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, elCanvas.width, elCanvas.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, elCanvas.width, elCanvas.height);
        ctx.restore();
      }

      // --- Build payload ---
      function buildPayload() {
        if (currentMode === 'text') {
          const txt = elTxt.value || '';
          if (!txt.trim()) return null;
          return new TextEncoder().encode(txt);
        } else {
          if (!loadedFile) return null;
          const nameBytes = new TextEncoder().encode(loadedFile.name);
          const totalLen = FILE_MAGIC.length + 2 + nameBytes.length + loadedFile.data.length;
          const payload = new Uint8Array(totalLen);
          let offset = 0;
          payload.set(FILE_MAGIC, offset);
          offset += FILE_MAGIC.length;
          payload[offset]     = (nameBytes.length >> 8) & 0xFF;
          payload[offset + 1] = nameBytes.length & 0xFF;
          offset += 2;
          payload.set(nameBytes, offset);
          offset += nameBytes.length;
          payload.set(loadedFile.data, offset);
          return payload;
        }
      }

      // --- Start/Stop ---
      async function start() {
        if (running) return;
        clearError();
        clearCanvas();

        if (!window.qram)   { showError("qram library didn't load. Check network / content blockers / file:// restrictions."); return; }
        if (!window.QRCode) { showError("qrcode library didn't load. Check network / content blockers / file:// restrictions."); return; }

        const data = buildPayload();
        if (!data || data.length === 0) {
          alert(currentMode === 'text' ? 'Enter text' : 'Select a file');
          return;
        }

        let sendData = data;
        if (elCompress.checked && window.qramCompress) {
          const cr = await qramCompress.maybeCompress(data);
          sendData = cr.data;
          if (cr.compressed) {
            elDataSize.textContent = `Data: ${formatBytes(cr.originalSize)} \u2192 ${formatBytes(cr.sentSize)} (gz)`;
          } else {
            elDataSize.textContent = `Data: ${formatBytes(cr.sentSize)} (no gz)`;
          }
        }

        const fps       = Math.max(1, Math.min(60, parseInt(elFPS.value, 10) || 6));
        const blockSize = Math.max(50, Math.min(20000, parseInt(elBlk.value, 10) || 300));
        const delay     = 1000 / fps;

        let enc;
        try {
          enc = new qram.Encoder({ data: sendData, blockSize });
        } catch (e) {
          showError('Failed to create qram.Encoder (bad options?)', e);
          return;
        }

        try {
          stream = await enc.createReadableStream();
          reader = stream.getReader();
        } catch (e) {
          showError('Failed to create/read QRAM stream.', e);
          return;
        }

        running = true;
        cancelRequested = false;
        setEncodeView(true);

        let n = 0;
        const blocks = Math.ceil(sendData.length / blockSize);
        const modeLabel = currentMode === 'file' ? `file: ${loadedFile.name}, ` : '';
        elStats.textContent = `${modeLabel}${formatBytes(sendData.length)}, ${blocks} blocks`;

        try {
          while (!cancelRequested) {
            const { value: pkt, done } = await reader.read();
            if (done) break;

            try {
              await QRCode.toCanvas(elCanvas, [{ data: pkt.data, mode: 'byte' }], {
                width: 350,
                margin: 1,
                errorCorrectionLevel: 'L'
              });
            } catch (e) {
              showError('QR render error (QRCode.toCanvas failed).', e);
              break;
            }

            n++;
            elStats.textContent = `${modeLabel}${formatBytes(sendData.length)}, ${blocks} blocks, packet #${n}`;
            await new Promise(ok => setTimeout(ok, delay));
          }
        } catch (e) {
          showError('Streaming loop error.', e);
        } finally {
          try { await reader?.cancel(); } catch (e) {}
          try { await stream?.cancel?.(); } catch (e) {}
          reader = null;
          stream = null;
          running = false;
          cancelRequested = false;
          setEncodeView(false);
        }
      }

      function stop() {
        cancelRequested = true;
        try { reader?.cancel(); } catch (e) {}
        try { stream?.cancel?.(); } catch (e) {}
      }

      elStart.addEventListener('click', start);
      elStop.addEventListener('click', stop);

      clearCanvas();
      updateDataSize();

      // Stop encode cleanly when user switches to Decode tab
      pageTabs.onEncodeDeactivate(() => {
        if (running) elStop.click();
      });
    })();

    // â”€â”€ Zone C: Decoder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Elements
    const video          = document.getElementById('video');
    const canvas         = document.getElementById('canvas');
    const ctx            = canvas.getContext('2d', { willReadFrequently: true });
    const statusEl       = document.getElementById('status');
    const progressFill   = document.getElementById('progress-fill');
    const blocksReceivedEl  = document.getElementById('blocks-received');
    const blocksTotalEl     = document.getElementById('blocks-total');
    const packetsScannedEl  = document.getElementById('packets-scanned');
    const speedDisplayEl    = document.getElementById('speed-display');
    const resultContainer   = document.getElementById('result-container');
    const resultLabel       = document.getElementById('result-label');
    const textResult        = document.getElementById('text-result');
    const fileResult        = document.getElementById('file-result');
    const fileResultName    = document.getElementById('file-result-name');
    const fileResultSize    = document.getElementById('file-result-size');
    const resultEl     = document.getElementById('result');
    const copyBtn      = document.getElementById('copy-btn');
    const downloadBtn  = document.getElementById('download-btn');
    const saveBtn      = document.getElementById('save-btn');
    const resetBtn     = document.getElementById('reset-btn');
    const errorMsg     = document.getElementById('error-msg');
    const scanIndicator = document.getElementById('scan-indicator');

    // State
    let scanning = true;
    let cameraStream = null;
    let decoder = null;
    let decodePromise = null;
    let packetsScanned = 0;
    let flashTimeout = null;
    let lastPacketSignature = null;
    let speedInterval = null;
    let pendingProgressUpdate = false;
    // Generation counter â€” incremented each time initCamera starts a new scan
    // loop. The loop closure captures its own gen; stale callbacks bail out
    // when scanGen advances, preventing double-loop races on reset/reinit.
    let scanGen = 0;

    // Speed tracking
    let firstPacketTime = null;
    let lastReceivedBlocks = 0;
    let lastTotalBlocks = 0;
    let totalBytesReceived = 0;

    // File transfer state
    let decodedFileData = null;

    // File protocol magic: "QRAMF"
    const FILE_MAGIC = [0x51, 0x52, 0x41, 0x4D, 0x46];

    // --- Helpers ---
    const { formatBytes, downloadBlob } = qramUtils;

    function formatSpeed(bytesPerSec) {
      if (bytesPerSec < 1024) return bytesPerSec.toFixed(0) + ' B/s';
      return (bytesPerSec / 1024).toFixed(1) + ' KB/s';
    }

    function isFileTransfer(data) {
      if (data.length < 8) return false;
      for (let i = 0; i < FILE_MAGIC.length; i++) {
        if (data[i] !== FILE_MAGIC[i]) return false;
      }
      return true;
    }

    function parseFileTransfer(data) {
      let offset = FILE_MAGIC.length;
      const nameLen = (data[offset] << 8) | data[offset + 1];
      offset += 2;
      if (offset + nameLen > data.length) return null;
      const nameBytes = data.slice(offset, offset + nameLen);
      const fileName = new TextDecoder().decode(nameBytes);
      offset += nameLen;
      const fileData = data.slice(offset);
      return { fileName, fileData };
    }

    function guessMimeType(fileName) {
      const ext = fileName.split('.').pop().toLowerCase();
      const types = {
        txt: 'text/plain', json: 'application/json', xml: 'text/xml',
        html: 'text/html', css: 'text/css', js: 'text/javascript',
        yaml: 'text/yaml', yml: 'text/yaml', toml: 'text/plain',
        ini: 'text/plain', cfg: 'text/plain', conf: 'text/plain',
        sh: 'text/x-shellscript', py: 'text/x-python',
        key: 'application/octet-stream', pem: 'application/x-pem-file',
        pub: 'text/plain', csv: 'text/csv', md: 'text/markdown',
        png: 'image/png', jpg: 'image/jpeg', jpeg: 'image/jpeg',
        gif: 'image/gif', svg: 'image/svg+xml', pdf: 'application/pdf',
        zip: 'application/zip', gz: 'application/gzip',
        tar: 'application/x-tar',
      };
      return types[ext] || 'application/octet-stream';
    }

    // --- Completion feedback ---
    function playCompletionChime() {
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playNote(freq, startTime, duration) {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          gain.gain.setValueAtTime(0.15, startTime);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
          osc.start(startTime);
          osc.stop(startTime + duration);
        }
        const now = audioCtx.currentTime;
        playNote(659, now, 0.15);
        playNote(880, now + 0.12, 0.2);
        playNote(1047, now + 0.24, 0.3);
      } catch (e) {}
    }

    function triggerCompletionFeedback() {
      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
      playCompletionChime();
    }

    // --- Speed tracking ---
    function updateSpeed() {
      if (!firstPacketTime || lastTotalBlocks === 0) return;
      const elapsed = (Date.now() - firstPacketTime) / 1000;
      if (elapsed < 0.5) return;
      const pps = packetsScanned / elapsed;
      const kbps = formatSpeed(totalBytesReceived / elapsed);
      speedDisplayEl.textContent = `${pps.toFixed(1)} pkt/s\n${kbps}`;
    }

    function startSpeedTracking() {
      if (speedInterval) return;
      speedInterval = setInterval(updateSpeed, 500);
    }

    function stopSpeedTracking() {
      if (speedInterval) {
        clearInterval(speedInterval);
        speedInterval = null;
      }
    }

    // Initialize
    async function init() {
      scanning = true;

      decoder = new qram.Decoder();
      decodePromise = decoder.decode();

      decodePromise.then(result => {
        onComplete(result).catch(err => {
          showError('Decode error: ' + err.message);
        });
      }).catch(err => {
        if (err.name !== 'AbortError') {
          showError('Decode error: ' + err.message);
        }
      });

      await initCamera();
    }

    // Initialize camera
    async function initCamera() {
      try {
        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', frameRate: { ideal: 30 }, height: { ideal: 1080 } },
        });
        video.srcObject = cameraStream;
        video.setAttribute('playsinline', true);

        await new Promise((resolve, reject) => {
          if (video.videoWidth > 0 && video.videoHeight > 0) {
            resolve();
          } else {
            video.addEventListener('loadedmetadata', resolve, { once: true });
            video.addEventListener('error', reject, { once: true });
          }
        });

        await video.play();
        statusEl.textContent = 'Point camera at animated QR...';

        // Advance generation so any leftover callbacks from a previous loop
        // exit cleanly, then start the new loop.
        const gen = ++scanGen;
        qramScan.scheduleFrame(video, () => scanFrame(gen));
      } catch (err) {
        scanning = false;
        if (decoder) decoder.cancel();
        showError('Camera access denied. Please allow camera permissions.');
        console.error(err);
      }
    }

    function showError(msg) {
      errorMsg.textContent = msg;
      errorMsg.classList.add('show');
    }

    function hideError() {
      errorMsg.classList.remove('show');
    }

    function flashIndicator() {
      scanIndicator.classList.add('flash');
      if (flashTimeout) clearTimeout(flashTimeout);
      flashTimeout = setTimeout(() => scanIndicator.classList.remove('flash'), 150);
    }

    function scheduleProgressUpdate() {
      if (pendingProgressUpdate) return;
      pendingProgressUpdate = true;
      requestAnimationFrame(() => {
        pendingProgressUpdate = false;
        const minFrames = lastTotalBlocks > 0 ? lastTotalBlocks : '?';
        packetsScannedEl.textContent = `${packetsScanned} / ${minFrames}`;
        blocksReceivedEl.textContent = lastReceivedBlocks;
        blocksTotalEl.textContent    = lastTotalBlocks;
        const pct = lastTotalBlocks > 0
          ? Math.min(100, (lastReceivedBlocks / lastTotalBlocks) * 100)
          : 0;
        progressFill.style.width = `${pct}%`;
        statusEl.textContent = `Receiving: ${lastReceivedBlocks}/${lastTotalBlocks} blocks`;
      });
    }

    // Scan frame â€” aligned to unique video frames via rVFC (rAF fallback).
    // `gen` is captured from scanGen at loop-start; stale closures bail out
    // when scanGen advances (reset/reinit), preventing double loops.
    async function scanFrame(gen) {
      if (!scanning || gen !== scanGen) return;

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        // Crop to the visible 85% scan region and downscale to 480px.
        const { width, height } = qramScan.cropCapture(video, canvas, ctx);
        const imageData = ctx.getImageData(0, 0, width, height);
        const code = jsQR(imageData.data, width, height, { inversionAttempts: 'dontInvert' });

        if (code && code.binaryData && code.binaryData.length > 0) {
          try {
            const packetData = new Uint8Array(code.binaryData);

            // Skip duplicate consecutive frames (encoder FPS << scan FPS).
            const len = packetData.length;
            const step = Math.max(1, len >> 5);
            let sig = len;
            for (let i = 0; i < len; i += step) sig = (sig * 31 + packetData[i]) | 0;

            if (sig !== lastPacketSignature) {
              lastPacketSignature = sig;

              const progress = await decoder.enqueue(packetData);
              packetsScanned++;
              totalBytesReceived += packetData.length;
              flashIndicator();

              if (!firstPacketTime) {
                firstPacketTime = Date.now();
                startSpeedTracking();
                hideError();
              }

              if (progress) {
                lastReceivedBlocks = progress.receivedBlocks;
                lastTotalBlocks    = progress.totalBlocks;
                scheduleProgressUpdate();
              }
            }
          } catch (err) {
            // Ignore invalid packets silently
          }
        }
      }

      if (scanning && gen === scanGen) {
        qramScan.scheduleFrame(video, () => scanFrame(gen));
      }
    }

    // Handle completion
    async function onComplete(result) {
      scanning = false;
      stopSpeedTracking();

      let data     = result.data;
      let wireSize = data.length;

      if (window.qramCompress) {
        const dr = await qramCompress.maybeDecompress(data);
        data     = dr.data;
        wireSize = dr.wireSize;
      }

      if (firstPacketTime) {
        const elapsed = (Date.now() - firstPacketTime) / 1000;
        if (elapsed > 0) {
          const pps = packetsScanned / elapsed;
          speedDisplayEl.textContent = `${pps.toFixed(1)} pkt/s\n${formatSpeed(wireSize / elapsed)}`;
        }
      }

      if (isFileTransfer(data)) {
        const parsed = parseFileTransfer(data);
        if (parsed) {
          decodedFileData = parsed;
          handleFileResult(parsed, data.length);
          return;
        }
      }

      handleTextResult(data);
    }

    function handleTextResult(data) {
      const text = new TextDecoder().decode(data);
      resultLabel.textContent    = 'Decoded Content';
      textResult.style.display   = '';
      fileResult.style.display   = 'none';
      resultEl.value             = text;
      resultContainer.classList.add('show');
      copyBtn.style.display      = 'block';
      saveBtn.style.display      = 'block';
      downloadBtn.style.display  = 'none';
      statusEl.textContent       = `Complete! ${formatBytes(data.length)} received.`;
      progressFill.style.width   = '100%';
      triggerCompletionFeedback();
      stopCamera();
    }

    function handleFileResult(parsed, totalBytes) {
      resultLabel.textContent         = 'Received File';
      textResult.style.display        = 'none';
      fileResult.style.display        = '';
      fileResultName.textContent      = parsed.fileName;
      fileResultSize.textContent      = formatBytes(parsed.fileData.length);
      resultContainer.classList.add('show');
      downloadBtn.style.display       = 'block';
      copyBtn.style.display           = 'none';
      saveBtn.style.display           = 'none';
      statusEl.textContent = `Complete! File "${parsed.fileName}" (${formatBytes(parsed.fileData.length)}) received.`;
      progressFill.style.width        = '100%';
      triggerCompletionFeedback();
      stopCamera();
    }

    function stopCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
    }

    // Copy to clipboard
    copyBtn.addEventListener('click', () => {
      qramUtils.copyToClipboard(resultEl.value, copyBtn, 'Copy to Clipboard', 'Copied!', 2000);
    });

    // Download file (for file transfers)
    downloadBtn.addEventListener('click', () => {
      if (!decodedFileData) return;
      const mime = guessMimeType(decodedFileData.fileName);
      downloadBlob(new Blob([decodedFileData.fileData], { type: mime }), decodedFileData.fileName);
    });

    // Save as file (for text transfers)
    saveBtn.addEventListener('click', () => {
      downloadBlob(new Blob([resultEl.value], { type: 'text/plain' }), 'qram-transfer.txt');
    });

    // Reset
    function handleReset() {
      scanning = false;
      stopSpeedTracking();
      if (decoder) decoder.cancel();
      stopCamera();

      packetsScanned = 0;
      totalBytesReceived = 0;
      lastPacketSignature = null;
      firstPacketTime = null;
      lastReceivedBlocks = 0;
      lastTotalBlocks = 0;
      decodedFileData = null;
      pendingProgressUpdate = false;

      resultContainer.classList.remove('show');
      textResult.style.display   = '';
      fileResult.style.display   = 'none';
      copyBtn.style.display      = 'none';
      downloadBtn.style.display  = 'none';
      saveBtn.style.display      = 'none';
      progressFill.style.width   = '0%';
      blocksReceivedEl.textContent  = '0';
      blocksTotalEl.textContent     = '?';
      packetsScannedEl.textContent  = '0 / ?';
      speedDisplayEl.textContent    = '--';
      hideError();

      init();
    }

    resetBtn.addEventListener('click', handleReset);

    // Register service worker for offline PWA support
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(() => {});
    }

    // â”€â”€ Lazy camera: start when Decode tab is activated â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Decode is the default active tab, so we also call init() immediately below.
    let _decoderStarted = false;

    pageTabs.onDecodeActivate(() => {
      if (!_decoderStarted) {
        _decoderStarted = true;
        init();
        return;
      }
      // Returning to Decode after switching away: restart only if no result showing
      const scanDone = resultContainer.classList.contains('show');
      if (!scanDone) init();
    });

    pageTabs.onDecodeDeactivate(() => {
      if (!scanning) return;  // Scan complete or not started â€” leave result alone
      // Pause an in-progress scan: stop camera, cancel decoder
      scanning = false;
      stopSpeedTracking();
      if (decoder) { decoder.cancel(); decoder = null; }
      if (cameraStream) { cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null; }
      video.srcObject = null;
      statusEl.textContent = 'Scan paused. Switch back to resume.';
    });

    // Decode is the default active tab â€” start immediately
    _decoderStarted = true;
    init();
  </script>
</body>
</html>
